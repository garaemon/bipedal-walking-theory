import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { ZMPConceptDiagram, ZMPSupportPolygonDiagram } from "@/components/diagrams/ZMPDiagram";
import { ZMPStabilityDiagram } from "@/components/diagrams/ZMPStabilityDiagram";

# ゼロモーメントポイント (ZMP)

ゼロモーメントポイントは、二足歩行における動的バランスの基準を提供する基礎的な概念です。
1969年にVukobratovicとJuricicによって提唱されたZMP理論は、
数十年にわたりほとんどのヒューマノイド歩行制御器の基礎となってきました。

## 定義

**ゼロモーメントポイント**は、すべての活性力（重力と慣性力）の合モーメントの
水平成分がゼロとなる地面上の点です。

### 第一原理からの導出

ZMP公式の由来を理解するために、地面上の点 $P = (p_x, 0, 0)$ を考えます。位置 $(x_i, y_i, z_i)$ にある各質量 $m_i$ には、重力 $-m_i g \hat{z}$ と慣性力 $-m_i \mathbf{a}_i$（ダランベールの原理）の2つの力が作用します。点 $P$ まわりのこれらの力のモーメントは:

$$
\boldsymbol{\tau}_P = \sum_{i=1}^{n} (\mathbf{r}_i - \mathbf{r}_P) \times (-m_i g \hat{z} - m_i \mathbf{a}_i)
$$

ZMPは、このモーメントの**水平成分**が消える点 $P$ として定義されます。$\tau_{P,y} = 0$（$y$ 軸まわりのモーメント）を設定し $p_x$ について解くと、ZMP公式が得られます。

$n$ 個の質点からなるシステムにおいて、ZMPの位置は:

<MathBlock tex="p_x^{zmp} = \frac{\sum_{i=1}^{n} m_i (\ddot{z}_i + g) x_i - \sum_{i=1}^{n} m_i \ddot{x}_i z_i}{\sum_{i=1}^{n} m_i (\ddot{z}_i + g)}" />

<MathBlock tex="p_y^{zmp} = \frac{\sum_{i=1}^{n} m_i (\ddot{z}_i + g) y_i - \sum_{i=1}^{n} m_i \ddot{y}_i z_i}{\sum_{i=1}^{n} m_i (\ddot{z}_i + g)}" />

<ZMPConceptDiagram />

## 物理的意味

ZMPは**圧力中心 (CoP)** と等価です。CoPとは地面反力が実効的に作用する点であり、
ロボットが地面と安定した接触状態にある限り、ZMPとCoPは一致します。

位置 $(x, y, z)$ にある単一質点を考えます。ZMPは次のように簡略化されます:

$$
p_x^{zmp} = x - \frac{z \ddot{x}}{\ddot{z} + g}
$$

$z = z_c$（一定）かつ $\ddot{z} = 0$ のLIPMの場合:

$$
p_x^{zmp} = x - \frac{z_c}{g}\ddot{x}
$$

これはLIPM方程式 $\ddot{x} = \frac{g}{z_c}(x - p_x)$ における支持点 $p_x$ と完全に一致します。

## 支持多角形

**支持多角形**は、ロボットと地面の間のすべての接触点の凸包です。

- **単脚支持**: 支持多角形は支持脚の足跡
- **両脚支持**: 支持多角形は両足を含む

<ZMPSupportPolygonDiagram />

### ZMP安定性基準

ロボットが動的バランスを維持するための必要十分条件:

> ZMPが支持多角形の内部にあること。

ZMPが支持多角形の端に達すると、ロボットは転倒し始めます。
これは歩行パターン生成で使用される基本的な拘束条件です。

<ZMPStabilityDiagram />

## ZMP vs CoP vs CoG

| 概念 | 定義 | 用途 |
|------|------|------|
| **CoG** (重心) | すべての質量の重み付き平均位置 | 静的バランス |
| **CoP** (圧力中心) | 地面反力が作用する点 | 測定可能な量 |
| **ZMP** (ゼロモーメントポイント) | 水平モーメントが消える点 | 動的バランス基準 |

ロボットが安定した地面接触状態にある場合、ZMP = CoPです。計算されたZMPが
支持多角形の外に出ると、実際のCoPは多角形の端に留まり、ロボットは傾きます。

## 運動データからのZMP計算

重心の軌道が与えられた場合、ZMPを計算できます:

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Simulate a simple CoM trajectory and compute ZMP
# Using a sinusoidal CoM motion
g = 9.81
z_c = 0.8  # constant CoM height

# Time parameters
dt = 0.01
t_values = [i * dt for i in range(101)]

# CoM trajectory: x(t) = A * sin(omega_walk * t)
A = 0.05        # amplitude (m)
omega_walk = 2 * math.pi / 0.6  # walking frequency

print("Time(s)  CoM_x(m)  CoM_xdd(m/s^2)  ZMP_x(m)")
print("-" * 50)

com_x_list = []
zmp_x_list = []

for i, t in enumerate(t_values):
    # CoM position and acceleration
    x = A * math.sin(omega_walk * t)
    xdd = -A * omega_walk**2 * math.sin(omega_walk * t)

    # ZMP computation (constant height, no vertical acceleration)
    zmp_x = x - (z_c / g) * xdd

    com_x_list.append(x)
    zmp_x_list.append(zmp_x)

    if i % 10 == 0:
        print(f"{t:5.2f}    {x:8.5f}    {xdd:8.4f}       {zmp_x:8.5f}")

# Plot CoM and ZMP trajectories
t_arr = np.array(t_values)
fig, axes = plt.subplots(2, 1, figsize=(8, 5), sharex=True)

axes[0].plot(t_arr, np.array(com_x_list) * 100, "b-", linewidth=2)
axes[0].set_ylabel("CoM x [cm]")
axes[0].set_title("CoM Trajectory")
axes[0].grid(True, alpha=0.3)

axes[1].plot(t_arr, np.array(com_x_list) * 100, "b-",
             linewidth=1.5, label="CoM x")
axes[1].plot(t_arr, np.array(zmp_x_list) * 100, "r--",
             linewidth=2, label="ZMP x")
axes[1].set_xlabel("Time [s]")
axes[1].set_ylabel("Position [cm]")
axes[1].set_title("ZMP vs CoM (note ZMP phase lead)")
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## 多体系のZMP

複数の剛体リンクを持つロボットでは、ZMPの計算はすべてのリンクにわたって総和をとります:

$$
p_x^{zmp} = \frac{\sum_{i=1}^{N} m_i(g + \ddot{z}_{G_i})x_{G_i} - \sum_{i=1}^{N}(m_i \ddot{x}_{G_i} z_{G_i} + I_{iy}\ddot{\theta}_{iy})}{\sum_{i=1}^{N} m_i(g + \ddot{z}_{G_i})}
$$

ここで、$(x_{G_i}, z_{G_i})$ はリンク $i$ の重心、$I_{iy}$ は $y$ 軸まわりの慣性モーメント、$\ddot{\theta}_{iy}$ は角加速度です。$I_{iy}\ddot{\theta}_{iy}$ の項は各リンクの**角運動量の寄与**を表します。リンクが回転すると（例: 腕の振り）、その角運動量の変化率が地面接触点まわりのモーメントを生成し、質点モデルの予測からZMPをずらします。低速歩行ではこれらの角運動量項は小さく無視できますが（より単純な質点ZMP公式が得られる）、走行やキック動作のような動的な運動では重要になります。

## ZMPに基づく歩行パターン生成

ZMPに基づく歩行の典型的なパイプライン:

1. **足踏みシーケンスの定義**: 各ステップの位置とタイミング
2. **ZMP参照軌道の設計**: 支持多角形内に留まる軌道
3. **CoM軌道の求解**: 目標ZMPを生成するCoM運動を求める
4. **関節軌道の生成**: 逆運動学を使用

ステップ3が計算上の核心的課題であり、プレビュー制御（第5章）で扱います。

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# ZMP reference trajectory for 3-step walk
# Simplified: ZMP shifts between left and right foot positions

foot_y_left = 0.05    # left foot y-position (m)
foot_y_right = -0.05  # right foot y-position (m)
foot_width = 0.06     # foot width in y-direction (m)
step_duration = 0.6   # seconds per step
dt = 0.01

# Footstep plan (y-positions of support foot)
footsteps = [
    (0.0, foot_y_left),         # step 1: left support
    (step_duration, foot_y_right),  # step 2: right support
    (2 * step_duration, foot_y_left),   # step 3: left support
]

print("=== ZMP Reference Trajectory (Lateral) ===")
print("Time(s)  ZMP_ref_y(m)  Support")
print("-" * 40)

total_time = 3 * step_duration
t = 0.0
t_list = []
zmp_ref_list = []
while t <= total_time:
    # Determine current support phase
    phase = int(t / step_duration)
    if phase >= len(footsteps):
        phase = len(footsteps) - 1

    zmp_ref_y = footsteps[phase][1]
    support = "Left" if zmp_ref_y > 0 else "Right"

    t_list.append(t)
    zmp_ref_list.append(zmp_ref_y)

    if int(t * 100) % 10 == 0:
        print(f"{t:5.2f}    {zmp_ref_y:8.4f}      {support}")
    t += dt

print()
print("The ZMP reference alternates between feet.")
print("Preview control (Ch.5) computes the CoM trajectory")
print("that tracks this ZMP reference.")

# Plot footstep rectangles and ZMP reference trajectory
fig, ax = plt.subplots(figsize=(8, 4))

colors = ["#4a90d9", "#d94a4a", "#4a90d9"]
labels_used = set()
for i, (t_start, foot_y) in enumerate(footsteps):
    t_end = t_start + step_duration
    y_lo = foot_y - foot_width / 2
    y_hi = foot_y + foot_width / 2
    side = "Left foot" if foot_y > 0 else "Right foot"
    lbl = side if side not in labels_used else None
    labels_used.add(side)
    ax.fill_between(
        [t_start, t_end], y_lo * 100, y_hi * 100,
        alpha=0.2, color=colors[i], label=lbl
    )
    ax.plot(
        [t_start, t_end, t_end, t_start, t_start],
        [y_lo * 100, y_lo * 100, y_hi * 100, y_hi * 100, y_lo * 100],
        color=colors[i], linewidth=1
    )

# Step transition lines
for i in range(1, len(footsteps)):
    t_switch = footsteps[i][0]
    ax.axvline(t_switch, color="gray", linestyle="--",
               linewidth=1, alpha=0.7,
               label="Step transition" if i == 1 else None)

ax.plot(t_list, np.array(zmp_ref_list) * 100, "k-",
        linewidth=2, label="ZMP ref")
ax.set_xlabel("Time [s]")
ax.set_ylabel("Lateral position [cm]")
ax.set_title("ZMP Reference Trajectory with Support Polygons")
ax.legend(loc="upper right", fontsize=8)
ax.grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## シミュレーション: ZMP安定性の可視化

以下のシミュレーションでは、穏やかなCoM運動（安定）と、急激な加速によりZMPが支持多角形の外に出るケース（不安定）を比較して、ZMP安定性基準を実演します。

<CodeEditor
  initialCode={`import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

g = 9.81
z_c = 0.8  # constant CoM height (m)

# Support polygon boundaries (single foot, x-direction)
foot_length = 0.20  # 20 cm foot
support_min = -foot_length / 2
support_max = foot_length / 2

dt = 0.005
t_arr = np.arange(0, 1.0, dt)

def compute_zmp_trajectory(amplitude, omega):
    """Compute CoM and ZMP for sinusoidal CoM motion."""
    com_x = amplitude * np.sin(omega * t_arr)
    com_xdd = -amplitude * omega**2 * np.sin(omega * t_arr)
    zmp_x = com_x - (z_c / g) * com_xdd
    return com_x, zmp_x

# Case 1: Stable (small amplitude, low frequency)
com_stable, zmp_stable = compute_zmp_trajectory(0.03, 2.0 * np.pi)

# Case 2: Unstable (large amplitude, high frequency)
com_unstable, zmp_unstable = compute_zmp_trajectory(0.08, 4.0 * np.pi)

fig, axes = plt.subplots(1, 2, figsize=(10, 4))

for ax, com_x, zmp_x, title in [
    (axes[0], com_stable, zmp_stable, "Stable: ZMP inside polygon"),
    (axes[1], com_unstable, zmp_unstable, "Unstable: ZMP exits polygon"),
]:
    # Support polygon background
    ax.fill_between(
        t_arr, support_min * 100, support_max * 100,
        alpha=0.15, color="green", label="Support polygon"
    )
    ax.axhline(support_min * 100, color="green",
               linestyle="-", linewidth=1.5, alpha=0.6)
    ax.axhline(support_max * 100, color="green",
               linestyle="-", linewidth=1.5, alpha=0.6)

    # Color ZMP by stability
    zmp_cm = zmp_x * 100
    in_support = (zmp_x >= support_min) & (zmp_x <= support_max)
    out_support = ~in_support

    # Plot ZMP segments with different colors
    ax.plot(t_arr, zmp_cm, color="gray", linewidth=0.5, alpha=0.3)
    if np.any(in_support):
        t_in = t_arr.copy()
        z_in = zmp_cm.copy()
        z_in[out_support] = np.nan
        ax.plot(t_in, z_in, "b-", linewidth=2, label="ZMP (stable)")
    if np.any(out_support):
        t_out = t_arr.copy()
        z_out = zmp_cm.copy()
        z_out[in_support] = np.nan
        ax.plot(t_out, z_out, "r-", linewidth=2.5, label="ZMP (unstable)")

    ax.plot(t_arr, com_x * 100, "k--", linewidth=1, alpha=0.6,
            label="CoM")
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("x position [cm]")
    ax.set_title(title)
    ax.legend(fontsize=7, loc="upper right")
    ax.grid(True, alpha=0.3)
    ax.set_ylim([-15, 15])

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()

# Print summary
n_total = len(t_arr)
stable_in = np.sum(
    (zmp_stable >= support_min) & (zmp_stable <= support_max)
)
unstable_in = np.sum(
    (zmp_unstable >= support_min) & (zmp_unstable <= support_max)
)
print(f"Stable case:   {stable_in}/{n_total} samples inside polygon "
      f"({100*stable_in/n_total:.1f}%)")
print(f"Unstable case: {unstable_in}/{n_total} samples inside polygon "
      f"({100*unstable_in/n_total:.1f}%)")
print()
print("When CoM acceleration is too large, the ZMP (red) exits")
print("the support polygon, indicating the robot would tip over.")
`}
/>

## ZMPの限界

1. **保守的**: ZMP基準は地面接触力のみを考慮し、角運動量を考慮しないため、過度に制約的である
2. **平坦地面の仮定**: 不整地へのZMPの拡張には修正が必要
3. **押し戻し回復なし**: ZMPベースの歩行器は、ZMPが支持多角形の外に押し出されるような大きな外乱から回復できない

これらの限界が**キャプチャポイント**理論（第6章）の発展につながりました。

## 参考文献

- M. Vukobratovic and J. Juricic, "[Contribution to the synthesis of biped gait](https://doi.org/10.1109/tbme.1969.4502596)," *IEEE Trans. Bio-Medical Engineering*, 1969.
- M. Vukobratovic and B. Borovac, "[Zero-Moment Point — Thirty five years of its life](https://www.cs.cmu.edu/~cga/legs/vukobratovic.pdf)," *Int. J. Humanoid Robotics*, 2004. ([DOI](https://doi.org/10.1142/S0219843604000083))

<InteractiveDemo title="ZMP Visualization">
  <p className="text-sm text-gray-500">
    Interactive ZMP trajectory and support polygon visualization coming soon.
  </p>
</InteractiveDemo>
