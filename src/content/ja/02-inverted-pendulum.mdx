import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { LIPMDiagram, WalkingTransitionDiagram } from "@/components/diagrams/InvertedPendulumDiagram";
import { LIPMPhasePlaneDiagram } from "@/components/diagrams/LIPMPhasePlaneDiagram";

# 倒立振子モデル

倒立振子は、二足歩行研究における最も基本的なモデルの一つです。
歩行者を無質量の脚の上にある質点として近似することで、歩行の本質的な力学を捉える
扱いやすい運動方程式を導出できます。

## 台車・ポールシステム

歩行の議論に入る前に、古典的な台車・ポール（台車上の倒立振子）を考えます。
長さ $l$、質量 $m$ の単純な倒立振子の運動方程式は:

$$
ml^2 \ddot{\theta} - mgl\sin\theta = \tau
$$

微小角度の場合（$\sin\theta \approx \theta$）、これは次のように線形化されます:

$$
\ddot{\theta} - \frac{g}{l}\theta = \frac{\tau}{ml^2}
$$

これは**不安定な**系です。その理由を確認するため、線形化された方程式を状態空間形式で書き直します。
状態ベクトルを $\mathbf{x} = [\theta, \dot{\theta}]^T$ と定義すると、$\tau = 0$（制御入力なし）の場合:

$$
\begin{bmatrix} \dot{\theta} \\ \ddot{\theta} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ g/l & 0 \end{bmatrix} \begin{bmatrix} \theta \\ \dot{\theta} \end{bmatrix}
$$

システム行列 $A$ の固有値は $\det(A - \lambda I) = 0$ から求められます:

$$
\lambda^2 - \frac{g}{l} = 0 \quad \Rightarrow \quad \lambda = \pm\sqrt{\frac{g}{l}}
$$

正の固有値 $\lambda_+ = +\sqrt{g/l}$ は指数関数的に発散するモードに対応し、
$\lambda_- = -\sqrt{g/l}$ は収束するモードに対応します。
微小な摂動でも発散モードが励起され、振子は指数関数的な速さで倒れます。
これが歩行が本質的に困難である根本的な理由です。二足歩行とは、
不安定なシステムを連続的に安定化する行為に他なりません。
能動的な制御（あるいは巧妙な受動力学）がなければ、歩行者は必ず転倒します。

## 線形倒立振子モデル (LIPM)

線形倒立振子モデルは、重心（CoM）を一定の高さ $z_c$ で移動するように拘束します。
これにより力学が劇的に簡略化されます。

<LIPMDiagram />

### 導出

質量 $m$ の質点が位置 $(x, z_c)$ にあり、無質量の脚が地面の点 $p_x$ に接触している場合を考えます。
拘束力は脚に沿って作用します。

水平方向と鉛直方向のニュートンの第二法則から:

$$
m\ddot{x} = F_x, \quad m\ddot{z} = F_z - mg
$$

$z = z_c$ が一定であるため、$\ddot{z} = 0$ となり、$F_z = mg$ です。

### 拘束力の消去

ここでの重要なステップは、脚が**剛体かつ無質量**であるため、
拘束力 $F$ は**脚の方向に沿って**作用しなければならないということです。
もし脚に垂直な成分があれば、無質量の脚に無限大の角加速度を生じさせてしまい、
物理的に不合理です。

脚は支持点 $(p_x, 0)$ から重心 $(x, z_c)$ に向かっています。
脚が鉛直方向となす角度を $\theta$ とすると、脚が形成する三角形の幾何学から、
拘束力 $F$ の水平・鉛直成分に分解できます:

$$
F_x = F \sin\theta = F \cdot \frac{x - p_x}{L}, \quad F_z = F \cos\theta = F \cdot \frac{z_c}{L}
$$

ここで $L = \sqrt{(x - p_x)^2 + z_c^2}$ は脚の長さです。
この2つの式の比をとると、$F$ と $L$ の両方が消去されます:

$$
\frac{F_x}{F_z} = \frac{x - p_x}{z_c}
$$

鉛直方向の方程式から $F_z = mg$ を代入すると:

$$
m\ddot{x} = \frac{mg}{z_c}(x - p_x)
$$

これにより、LIPMの基本方程式が得られます:

<MathBlock tex="\ddot{x} = \frac{g}{z_c}(x - p_x)" />

ここで、$x$ はCoMの位置、$p_x$ は足（支持点）の位置、
$g$ は重力加速度、$z_c$ は一定のCoM高さです。

### 固有振動数

固有振動数を定義します:

$$
\omega = \sqrt{\frac{g}{z_c}}
$$

LIPM方程式は $\ddot{x} = \omega^2(x - p_x)$ となります。

### 解析解

支持点が原点にある場合（$p_x = 0$）、一般解は:

$$
x(t) = x_0 \cosh(\omega t) + \frac{\dot{x}_0}{\omega}\sinh(\omega t)
$$

$$
\dot{x}(t) = x_0 \omega \sinh(\omega t) + \dot{x}_0 \cosh(\omega t)
$$

ここで、$x_0 = x(0)$ と $\dot{x}_0 = \dot{x}(0)$ は初期条件です。

三角関数（$\cos$, $\sin$）ではなく双曲線関数（$\cosh$, $\sinh$）を使用していることに注意してください。
これは倒立振子の力学の不安定な（発散する）性質を反映しています。

## 3次元への拡張 (3D-LIPM)

LIPMは自然に3次元に拡張できます。CoMが高さ $z_c$ に拘束される場合:

$$
\ddot{x} = \frac{g}{z_c}(x - p_x), \quad \ddot{y} = \frac{g}{z_c}(y - p_y)
$$

$x$ と $y$ の力学は**非結合**であり、これは歩行パターン生成にとって大きな利点です:
矢状面と側方の運動を独立に計画できます。

## 軌道エネルギー

LIPMの力学を解析するのに有用な概念が**軌道エネルギー**です:

$$
E = \frac{1}{2}\dot{x}^2 - \frac{1}{2}\omega^2(x - p_x)^2
$$

この量は単脚支持相の間保存されます。軌道の分類:
- $E > 0$: CoMが支持点を越える（歩行）
- $E = 0$: CoMが支持点に漸近的に近づくか離れる
- $E < 0$: CoMが支持点の周りで振動する（歩行としては物理的に意味がない）

### 軌道エネルギーの直感的理解

直感を養うために、丘の上を転がるボールのアナロジーを考えましょう。
鞍点のような形の地形にボールが置かれた状況を想像してください。
十分な運動エネルギーがあれば丘を越えられますが、
そうでなければ谷で振動するだけです。
軌道エネルギー $E$ は、このアナロジーにおける全力学的エネルギーの役割を果たします。

$E > 0$ の場合、CoMは支持点を「乗り越える」のに十分な運動エネルギーを持っています。
これが歩行の状態です。身体は片足の上を通過して次の一歩へと進みます。
典型的な歩行では、軌道エネルギーは各単脚支持相を通じて正のまま保たれます。

$E = 0$ の場合、軌道はちょうど**分離線**（セパラトリクス、歩行領域と非歩行領域の境界）上にあります。
この場合、CoMが支持点に到達する（または離れる）のに無限の時間がかかります。
これは実際には正確に実現されない理論的な境界ですが、
歩行に必要な最小エネルギーを定義しています。

軌道エネルギーの保存は強力な性質です。なぜなら、
初期状態だけで軌道全体が決まることを意味するからです。
単脚支持相のある瞬間のCoMの位置と速度を知っていれば、
他のすべての瞬間のCoMの状態を予測できます。
これによりLIPMは解析的に扱いやすくなり、
歩行パターン生成で広く使われている主な理由の一つです。

### 位相平面の可視化

位相平面は位置 $x$ と速度 $\dot{x}$ をプロットし、
力学の大域的構造を明らかにします。
以下の図の各曲線は一定の軌道エネルギーレベルを表しています。

<LIPMPhasePlaneDiagram />

## Python シミュレーション: LIPM軌道

<CodeEditor
  initialCode={`import math

# LIPM parameters
g = 9.81      # gravity (m/s^2)
z_c = 0.8     # CoM height (m)
omega = math.sqrt(g / z_c)  # natural frequency

print(f"Natural frequency: omega = {omega:.3f} rad/s")
print(f"Time constant: 1/omega = {1/omega:.3f} s")
print()

# Initial conditions
x0 = -0.1    # initial CoM position (m)
xd0 = 0.3    # initial CoM velocity (m/s)
p_x = 0.0    # support point at origin

# Simulate LIPM trajectory
dt = 0.01
t_end = 1.0
steps = int(t_end / dt)

print("Time(s)  x(m)     xdot(m/s)  Energy")
print("-" * 45)

time_list = []
x_list = []
xdot_list = []

for i in range(0, steps + 1):
    t = i * dt
    # Analytical solution (support at origin)
    x = x0 * math.cosh(omega * t) + (xd0 / omega) * math.sinh(omega * t)
    xdot = x0 * omega * math.sinh(omega * t) + xd0 * math.cosh(omega * t)
    time_list.append(t)
    x_list.append(x)
    xdot_list.append(xdot)
    # Orbital energy (should be conserved)
    if i % 10 == 0:
        energy = 0.5 * xdot**2 - 0.5 * omega**2 * x**2
        print(f"{t:5.2f}    {x:7.4f}  {xdot:7.4f}    {energy:7.4f}")

# Plot time series and phase plane
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

fig, axes = plt.subplots(2, 1, figsize=(8, 6))

# Upper: time series of x(t) and xdot(t)
axes[0].plot(time_list, x_list, label='x(t) [m]', color='tab:blue')
axes[0].plot(time_list, xdot_list, label='xdot(t) [m/s]',
             color='tab:orange')
axes[0].set_xlabel('Time [s]')
axes[0].set_ylabel('Value')
axes[0].set_title('LIPM Trajectory: Time Series')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Lower: phase plane (x vs xdot)
axes[1].plot(x_list, xdot_list, color='tab:green', linewidth=2)
axes[1].plot(x_list[0], xdot_list[0], 'o', color='tab:blue',
             markersize=8, label='Start')
axes[1].plot(x_list[-1], xdot_list[-1], 's', color='tab:red',
             markersize=8, label='End')
axes[1].set_xlabel('x [m]')
axes[1].set_ylabel('xdot [m/s]')
axes[1].set_title('LIPM Trajectory: Phase Plane')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## LIPMによる歩行

<WalkingTransitionDiagram />

歩行パターンを生成するために、複数の単脚支持相を連鎖させます。
各歩行遷移で、支持点が新しい足の位置に移動します。

### 歩行間遷移マップ

**歩行間遷移マップ**は、一つの単脚支持相の終了時の状態
$(x, \dot{x})$（現在の支持足を基準とした座標）を受け取り、
次の支持相の開始時の状態（新しい支持足を基準とした座標）に写す関数です。
ロボットが歩幅 $d$ の一歩を踏み出すとき、新しい座標系での位置は
$x_{\text{new}} = x_{\text{end}} - d$ となり、速度は変化しません:
$\dot{x}_{\text{new}} = \dot{x}_{\text{end}}$。

遷移マップに**不動点**が存在するとき、**周期歩行**が成立します。
つまり、各歩の開始時の状態が同一であることを意味します。
ロボットは毎歩同じ軌道を繰り返し、これが定常歩行そのものです。

### 初速度にtanhが現れる理由

歩行周期 $T$、歩幅 $d$ の周期歩行では、対称性から
CoMは $x = -d/2$（支持足の後方）から始まり
$x = +d/2$（支持足の前方）で終わる必要があります。
LIPMの解析解に代入して初速度 $\dot{x}_0$ を求めると:

$$
\dot{x}_0 = \frac{d/2 \cdot \omega}{\tanh(\omega T / 2)}
$$

$\tanh$ 関数が現れるのは、$\cosh$ と $\sinh$ が
$\cosh^2 - \sinh^2 = 1$ を満たし、対称条件が
$x_0 / (\dot{x}_0 / \omega) = -\tanh(\omega T / 2)$ を要求するためです。
$\tanh(\omega T / 2) < 1$ であるため、必要な初速度は常に
$d \omega / 2$ より大きくなり、
不安定な力学を克服するための余分なエネルギーを反映しています。

<CodeEditor
  initialCode={`import math

# LIPM walking simulation
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)
T_step = 0.4  # step duration (s)

# Step length pattern (alternating feet)
step_length = 0.2  # meters

# Start at the support foot
x = -step_length / 2  # CoM starts behind support
xdot = (step_length / 2) * omega / math.tanh(omega * T_step / 2)

print(f"Step duration: {T_step:.2f} s")
print(f"Step length: {step_length:.2f} m")
print(f"Initial velocity: {xdot:.4f} m/s")
print()

support_x = 0.0
print("Step  t(s)    CoM_x(m)  Velocity(m/s)  Support(m)")
print("-" * 55)

num_steps = 5
dt = 0.01
com_trajectory = []
support_points = [support_x]

for step in range(num_steps):
    # Simulate one step
    n_substeps = int(T_step / dt) + 1
    for i in range(n_substeps):
        t = i * dt
        dx = x - support_x
        x_t = (support_x + dx * math.cosh(omega * t)
               + (xdot / omega) * math.sinh(omega * t))
        xdot_t = (dx * omega * math.sinh(omega * t)
                  + xdot * math.cosh(omega * t))
        com_trajectory.append(x_t)

    # State at end of step
    x = x_t
    xdot = xdot_t
    print(f"  {step}    {(step+1)*T_step:.2f}   {x:8.4f}"
          f"     {xdot:8.4f}      {support_x:.3f}")

    # Transition: shift support to new foot
    support_x += step_length
    support_points.append(support_x)

# Plot multi-step CoM trajectory
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

total_samples = len(com_trajectory)
time_array = [i * dt for i in range(total_samples)]

fig, ax = plt.subplots(figsize=(10, 4))
ax.plot(time_array, com_trajectory, color='tab:blue',
        linewidth=1.5, label='CoM x(t)')

# Mark support point transitions
for idx, sp in enumerate(support_points):
    t_switch = idx * T_step
    ax.axvline(x=t_switch, color='gray', linestyle='--',
               alpha=0.5)
    ax.plot(t_switch, sp, 'v', color='tab:red', markersize=10,
            label='Support' if idx == 0 else None)

ax.set_xlabel('Time [s]')
ax.set_ylabel('x position [m]')
ax.set_title('Multi-Step LIPM Walking: CoM Trajectory')
ax.legend()
ax.grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## シミュレーション: LIPM位相面図

位相面図はLIPMの力学の大域的構造を明らかにします。
軌道は軌道エネルギー $E$ によって分類されます:
正のエネルギー（歩行）、ゼロエネルギー（分離線）、負のエネルギー（振動）。

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# LIPM model parameters
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)

print(f"omega = {omega:.3f} rad/s")
print()

# Generate phase portrait
x_range = np.linspace(-0.3, 0.3, 400)

fig, ax = plt.subplots(figsize=(8, 6))

# E < 0: oscillatory trajectories (not physical for walking)
energy_neg = [-0.01, -0.03, -0.06]
for e_val in energy_neg:
    # xdot^2 = 2*E + omega^2 * x^2, only valid where >= 0
    xdot_sq = 2 * e_val + omega**2 * x_range**2
    valid = xdot_sq >= 0
    if np.any(valid):
        xdot_pos = np.sqrt(xdot_sq[valid])
        ax.plot(x_range[valid], xdot_pos,
                color='tab:blue', alpha=0.7, linewidth=1)
        ax.plot(x_range[valid], -xdot_pos,
                color='tab:blue', alpha=0.7, linewidth=1)
    print(f"E = {e_val:.2f}: closed orbit (oscillation)")

# E = 0: separatrix
xdot_sep_pos = omega * np.abs(x_range)
ax.plot(x_range, xdot_sep_pos, color='black',
        linewidth=3, label='E = 0 (separatrix)')
ax.plot(x_range, -xdot_sep_pos, color='black',
        linewidth=3)
print(f"E =  0.00: separatrix (boundary)")

# E > 0: walking trajectories
energy_pos = [0.01, 0.03, 0.06]
for e_val in energy_pos:
    xdot_sq = 2 * e_val + omega**2 * x_range**2
    xdot_pos = np.sqrt(xdot_sq)
    ax.plot(x_range, xdot_pos,
            color='tab:red', alpha=0.7, linewidth=1)
    ax.plot(x_range, -xdot_pos,
            color='tab:red', alpha=0.7, linewidth=1)
    print(f"E = {e_val:5.2f}: open orbit (walking)")

# Labels and formatting
ax.set_xlabel('x [m]', fontsize=12)
ax.set_ylabel('xdot [m/s]', fontsize=12)
ax.set_title('LIPM Phase Portrait', fontsize=14)
ax.axhline(y=0, color='gray', linewidth=0.5)
ax.axvline(x=0, color='gray', linewidth=0.5)

# Custom legend
from matplotlib.lines import Line2D
legend_items = [
    Line2D([0], [0], color='tab:red', linewidth=2,
           label='E > 0 (walking)'),
    Line2D([0], [0], color='black', linewidth=3,
           label='E = 0 (separatrix)'),
    Line2D([0], [0], color='tab:blue', linewidth=2,
           label='E < 0 (oscillation)'),
]
ax.legend(handles=legend_items, fontsize=11)
ax.grid(True, alpha=0.3)
ax.set_xlim(-0.3, 0.3)
ax.set_ylim(-1.2, 1.2)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## LIPMの限界

LIPMは強力なモデルですが、重要な限界があります:

1. **一定高さの仮定**: 実際の歩行では鉛直方向のCoM運動が存在する
2. **質点モデル**: 四肢や体幹の角運動量を無視している
3. **無質量の脚**: 脚の振り動力学が捉えられない
4. **両脚支持なし**: 遷移が瞬時に行われる

これらの限界は、後の章で扱うより高度なモデルの動機となります。

## 参考文献

- S. Kajita et al., "[The 3D Linear Inverted Pendulum Mode: A simple modeling for a biped walking pattern generation](https://doi.org/10.1109/IROS.2001.973365)," *Proc. IEEE/RSJ IROS*, 2001.
- S. Kajita et al., "[Biped Walking Pattern Generation by using Preview Control of Zero-Moment Point](https://doi.org/10.1109/ROBOT.2003.1241826)," *Proc. IEEE ICRA*, 2003.

<InteractiveDemo title="LIPM Simulation">
  <p className="text-sm text-gray-500">
    Interactive LIPM simulation with adjustable parameters coming soon.
  </p>
</InteractiveDemo>
