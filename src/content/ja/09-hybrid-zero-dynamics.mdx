import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { VirtualConstraintDiagram } from "@/components/diagrams/HZDDiagram";
import { HybridAutomatonDiagram } from "@/components/diagrams/HybridAutomatonDiagram";
import { ZeroDynamicsSurfaceDiagram } from "@/components/diagrams/ZeroDynamicsSurfaceDiagram";
import { VirtualVsPhysicalConstraintDiagram } from "@/components/diagrams/VirtualVsPhysicalConstraintDiagram";

# ハイブリッドゼロダイナミクス

ハイブリッドゼロダイナミクス (HZD) は、証明可能な安定歩行を設計するための厳密な数学的枠組みを提供します。ヒューリスティックな手法とは異なり、HZDは慎重に設計された仮想制約を通じて軌道安定性を保証します。

## なぜHZDなのか？ 軌道追従の問題点

従来の歩行制御器は**時間ベースの軌道追従**に依存しています。つまり「時刻 $t = 0.3$ 秒で膝は30度であるべき」と指定します。平坦な地面で外乱がなければこれで問題ありませんが、根本的な欠陥があります。

歩行中にロボットが後ろから押されて減速した場面を想像してください。時間ベースの制御器は、ロボットのステップがまだ十分に進んでいないにもかかわらず、$t = 0.3$ 秒で同じ膝角度を要求し続けます。その結果、指令軌道がロボットの実際の物理状態と一致しなくなり、転倒につながることがよくあります。

HZDは根本的に異なるアプローチを取ります。時間ではなく、**位相変数** $\theta(\mathbf{q})$ によって軌道をパラメータ化します。位相変数は、現在のステップにおけるロボットの進行度合いを測定します。ロボットが押されて減速すれば位相の進行も遅くなり、目標関節軌道も自動的に遅くなります。

この**位相ベースのパラメータ化**により、HZDはタイミング外乱に対する本質的なロバスト性を獲得しています。これがHZDの最も重要な実用的利点の一つです。

## 仮想制約

仮想制約とは、物理的な機構ではなくフィードバック制御によって実現されるホロノミック制約です。関節運動を単一の**位相変数** $\theta(\mathbf{q})$ の関数としてパラメータ化します:

$$
y = h(\mathbf{q}) - h_d(\theta(\mathbf{q}))
$$

ここで $h(\mathbf{q})$ は制御出力を選択し、$h_d(\theta)$ は位相変数の関数として望ましい出力を定義します。

<VirtualConstraintDiagram />

<VirtualVsPhysicalConstraintDiagram />

### 位相変数

位相変数 $\theta(\mathbf{q})$ は以下の条件を満たす必要があります:
- **単調増加**: 歩行ステップ中に増加し続ける（時計の役割を果たす）
- **姿勢依存**: 時間ベースではない（歩容のロバスト性を高める）

一般的な選択: 支持脚の角度（垂直方向に対する股関節角度）。

### ベジエ多項式パラメータ化

望ましい出力は通常、ベジエ多項式を用いてパラメータ化されます:

$$
h_d(\theta) = \sum_{k=0}^{M} \alpha_k \binom{M}{k} s^k (1-s)^{M-k}
$$

ここで $s = \frac{\theta - \theta^+}{\theta^- - \theta^+} \in [0, 1]$ は位相を正規化し、$\alpha_k$ は最適化されるベジエ係数です。

### なぜベジエ多項式なのか？

ベジエ多項式は、他の基底関数（フーリエ級数、3次スプラインなど）ではなく以下の有用な性質から選ばれています:

1. **滑らかさ**: ベジエ曲線は $C^\infty$ 連続であり、関節速度や加速度が滑らかになります。これは実機でトルクのスパイクを防ぐために重要です。
2. **凸包性**: 曲線は制御点 $\alpha_k$ の凸包の中に留まることが保証されます。これにより最適化中に関節角度の範囲制約を容易に課すことができます。
3. **導関数の簡潔さ**: $M$ 次ベジエ曲線の導関数は、係数 $M(\alpha_{k+1} - \alpha_k)$ を持つ $(M-1)$ 次ベジエ曲線になります。これにより速度・加速度の解析的な計算が簡単になります。
4. **端点補間**: $h_d(s=0) = \alpha_0$, $h_d(s=1) = \alpha_M$ が正確に成立し、軌道の開始値と終了値を直接制御できます。

## ハイブリッドシステムモデル

歩行は、連続ダイナミクスと離散イベントが交互に切り替わる**ハイブリッドシステム**としてモデル化されます。以下の図がこのサイクルを示しています:

<HybridAutomatonDiagram />

### 連続相 (遊脚期)

遊脚期では、ロボットはマニピュレータ方程式で支配される多体システムです:

$$
M(\mathbf{q})\ddot{\mathbf{q}} + \mathbf{h}(\mathbf{q}, \dot{\mathbf{q}}) = B\mathbf{u}
$$

ここで $M(\mathbf{q})$ は慣性行列、$\mathbf{h}$ はコリオリ・遠心力・重力項、$B$ は入力写像行列、$\mathbf{u}$ は関節トルクベクトルです。状態空間形式では:

$$
\dot{\mathbf{x}} = f(\mathbf{x}) + g(\mathbf{x})\mathbf{u}
$$

ここで $\mathbf{x} = [\mathbf{q}^T, \dot{\mathbf{q}}^T]^T$ は完全状態です。

二足歩行ロボットは**劣駆動系**であることに注意してください。支持脚の足首にはモータがないため、$B$ の列数は $\mathbf{q}$ の行数より少なくなります。

### 離散相 (衝撃)

踵接地時（切り替え面 $S$ に到達した時）:

$$
\mathbf{x}^+ = \Delta(\mathbf{x}^-)
$$

### 衝撃写像と脚のラベル付け替え

衝撃写像 $\Delta$ は二つの同時的な効果を表します:

**速度ジャンプ。** 地面が接触点に衝撃力を及ぼし、関節速度が瞬間的に変化します。新しい接触点まわりの角運動量は保存されます（衝撃的な地面反力がその点を通過するため）。これにより:

$$
\dot{\mathbf{q}}^+ = H_{\text{impact}}(\mathbf{q}^-) \, \dot{\mathbf{q}}^-
$$

行列 $H_{\text{impact}}$ は衝撃時の姿勢のみに依存し（速度には依存しない）、速度写像は $\dot{\mathbf{q}}^-$ に関して線形です。

**脚のラベル付け替え。** 遊脚が新しい支持脚になり、支持脚が新しい遊脚になります。関節座標が再インデックスされます: $q_{\text{swing}}$ が $q_{\text{stance}}$ に、$q_{\text{stance}}$ が $q_{\text{swing}}$ になります。このラベル付け替えは置換行列 $R$ で表されます:

$$
\mathbf{q}^+ = R \, \mathbf{q}^-
$$

## ゼロダイナミクス

仮想制約が完全に実現されている場合 ($y = 0, \dot{y} = 0$)、システムは低次元の**ゼロダイナミクス面**上で発展します。

### ゼロダイナミクスの導出

ゼロダイナミクスがどのように導かれるか、制御設計を段階的に説明します。

**ステップ1: 出力の定義。** 仮想制約の出力を定義します:

$$
y = h_d(\mathbf{q}) - h_a(\mathbf{q}, s)
$$

ここで $h_d(\mathbf{q})$ は実際の関節値（制御出力）を選択し、$h_a(\mathbf{q}, s)$ は位相変数 $s = s(\theta(\mathbf{q}))$ でパラメータ化された目標軌道です。

**ステップ2: 入出力線形化。** $y$ を時間で2回微分します。これらの微分を簡潔に表現するために、非線形制御理論の**リー微分**の記法を導入します。

**リー微分の定義。** スカラー関数 $h(\mathbf{x})$ とベクトル場 $f(\mathbf{x})$ に対して、$f$ に沿った $h$ のリー微分は、$f$ の方向への $h$ の方向微分として定義されます:

$$
L_f h(\mathbf{x}) = \frac{\partial h}{\partial \mathbf{x}} f(\mathbf{x}) = \nabla h \cdot f
$$

直感的には、$L_f h$ は**状態が $f$ に沿って流れるときに $h$ がどれだけ速く変化するか**を測定します。$\dot{\mathbf{x}} = f(\mathbf{x})$ のとき、$\frac{d}{dt}h(\mathbf{x}) = L_f h(\mathbf{x})$ です。

高次のリー微分は繰り返し適用で得られます:

$$
L_f^2 h = L_f(L_f h) = \frac{\partial (L_f h)}{\partial \mathbf{x}} f(\mathbf{x})
$$

制御アフィン系 $\dot{\mathbf{x}} = f(\mathbf{x}) + g(\mathbf{x})\mathbf{u}$ に対する混合リー微分 $L_g L_f h$ は、$h$ の2階時間微分に対する制御入力の影響を捉えます。

この記法を用いると、システムが制御アフィンであるため、$y$ の2階微分には $\mathbf{u}$ を含む項が現れます:

$$
\ddot{y} = L_f^2 y + L_g L_f y \cdot \mathbf{u}
$$

出力が以下に従うように制御入力 $\mathbf{u}$ を選びます:

$$
\ddot{y} = -K_p y - K_d \dot{y}
$$

これは出力 $y$ を指数的にゼロに駆動するPD的な制御則です。適切なゲイン $K_p, K_d > 0$ により、$y(t) \to 0$ かつ $\dot{y}(t) \to 0$ となります。

**ステップ3: ゼロダイナミクス面。** $y = 0$ と $\dot{y} = 0$ が正確に満たされると、仮想制約は完全に実現されます。システムは**ゼロダイナミクス面** $Z$ 上に拘束されます:

$$
Z = \{(\mathbf{q}, \dot{\mathbf{q}}) \mid y = 0, \dot{y} = 0\}
$$

<ZeroDynamicsSurfaceDiagram />

**ステップ4: 次元の低減。** この面上では、元の $n$ 自由度システムがより低次元のシステムに帰着されます。例えば、2リンク平面二足歩行ロボットは2自由度です。仮想制約が1つの場合、ゼロダイナミクスは $2 - 1 = 1$ 自由度となり、以下で記述されます:

$$
\ddot{\theta} = \kappa(\theta, \dot{\theta})
$$

これは仮想制約が満たされたときの歩行挙動を完全に決定する2階システムです。

## 安定性解析

歩容は**ハイブリッドゼロダイナミクス**が安定な周期軌道を持つ場合に安定です。

### ゼロダイナミクス上のポアンカレ写像

ゼロダイナミクスは2次元（状態 $\theta, \dot{\theta}$）であるため、ポアンカレ写像はスカラー写像に帰着されます:

$$
\dot{\theta}_{n+1}^+ = \rho(\dot{\theta}_n^+)
$$

$\dot{\theta}^* = \rho(\dot{\theta}^*)$ を満たす不動点 $\dot{\theta}^*$ は、$|\rho'(\dot{\theta}^*)| < 1$ のとき安定です。

<CodeEditor
  initialCode={`import math

def evaluate_bezier(alpha, s):
    """Evaluate Bezier polynomial at normalized phase s."""
    M = len(alpha) - 1
    result = 0.0
    for k in range(M + 1):
        binom = (math.factorial(M)
                 // (math.factorial(k)
                     * math.factorial(M - k)))
        result += alpha[k] * binom * s**k * (1-s)**(M-k)
    return result

def evaluate_bezier_derivative(alpha, s):
    """Evaluate derivative of Bezier polynomial."""
    M = len(alpha) - 1
    if M == 0:
        return 0.0
    d_alpha = [M*(alpha[k+1]-alpha[k]) for k in range(M)]
    return evaluate_bezier(d_alpha, s)

alpha_hip = [0.3, 0.25, 0.1, -0.1, -0.25, -0.3]
theta_plus = -0.2
theta_minus = 0.2

print("=== Virtual Constraint (Hip Angle) ===")
print(f"Bezier order: {len(alpha_hip) - 1}")
print(f"Coefficients: {alpha_hip}")
print(f"Phase range: [{theta_plus:.2f}, {theta_minus:.2f}]")
print()
print("Phase(s)  Desired_hip(deg)  Velocity(deg/s)")
print("-" * 48)

for i in range(11):
    s = i / 10.0
    hip_d = evaluate_bezier(alpha_hip, s)
    hip_v = evaluate_bezier_derivative(alpha_hip, s)
    hip_v /= (theta_minus - theta_plus)
    print(f"  {s:.1f}      {math.degrees(hip_d):8.2f}"
          f"         {math.degrees(hip_v):8.2f}")

print()
start_deg = math.degrees(evaluate_bezier(alpha_hip, 0))
end_deg = math.degrees(evaluate_bezier(alpha_hip, 1))
print("The hip angle smoothly transitions from")
print(f"  {start_deg:.1f} deg (start)")
print(f"  to {end_deg:.1f} deg (end)")

# --- Plot Bezier curve with control points and velocity ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

s_vals = np.linspace(0, 1, 200)
curve_vals = [evaluate_bezier(alpha_hip, s) for s in s_vals]
deriv_vals = [
    evaluate_bezier_derivative(alpha_hip, s)
    / (theta_minus - theta_plus) for s in s_vals]
curve_deg = np.degrees(curve_vals)
deriv_deg = np.degrees(deriv_vals)
alpha_deg = [math.degrees(a) for a in alpha_hip]

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(7, 6))
M = len(alpha_hip) - 1
ctrl_s = [k / M for k in range(M + 1)]
ax1.plot(s_vals, curve_deg, "b-", linewidth=2,
         label="Bezier curve")
ax1.plot(ctrl_s, alpha_deg, "rs--", markersize=8,
         linewidth=1, label="Control points")
ax1.fill_between(
    s_vals, min(alpha_deg), max(alpha_deg),
    alpha=0.1, color="red", label="Convex hull bound")
ax1.set_xlabel("Normalized phase s")
ax1.set_ylabel("Hip angle (deg)")
ax1.set_title("Bezier Virtual Constraint with Control Points")
ax1.legend(fontsize=8)
ax1.grid(True, alpha=0.3)

ax2.plot(s_vals, deriv_deg, "g-", linewidth=2)
ax2.axhline(y=0, color="k", linestyle="--", linewidth=0.5)
ax2.set_xlabel("Normalized phase s")
ax2.set_ylabel("dh/ds (deg/rad)")
ax2.set_title("Velocity Profile (dh/ds)")
ax2.grid(True, alpha=0.3)

fig.tight_layout()
buf = io.BytesIO()
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## 歩容最適化

良いベジエ係数 $\alpha$ を見つけるには最適化が必要です:

$$
\min_{\alpha} J(\alpha) \quad \text{s.t. stability and physical constraints}
$$

コスト $J$ には通常以下が含まれます:
- 歩行速度
- エネルギー消費（トルクの二乗）
- 足のクリアランス
- 衝撃力

制約条件には以下が含まれます:
- 不動点安定性: $|\rho'(\dot{\theta}^*)| < 1$
- 足のクリアランス: 遊脚が地面より上にあること
- 摩擦錐: 滑りがないこと
- トルク制限

<CodeEditor
  initialCode={`import math

def compute_poincare_map(theta_dot_plus,
                         step_length=0.3):
    """Simplified return map for zero dynamics."""
    g = 9.81
    l = 0.8
    energy_in = theta_dot_plus**2
    half_a = math.asin(step_length / (2 * l))
    impact_ratio = math.cos(2 * half_a)
    energy_out = energy_in * impact_ratio**2
    energy_out += 2*g/l * (1 - math.cos(half_a))
    if energy_out < 0:
        return 0.0
    return math.sqrt(energy_out)

print("=== Poincare Map Analysis ===")
print()
theta_dot = 1.5
print("Iter  theta_dot_in  theta_dot_out  Converged?")
print("-" * 52)

fixed_point = None
for i in range(15):
    td_out = compute_poincare_map(theta_dot)
    err = abs(td_out - theta_dot)
    conv = "YES" if err < 0.001 else ""
    print(f"  {i:2d}      {theta_dot:8.4f}"
          f"      {td_out:8.4f}       {conv}")
    if err < 0.001:
        fixed_point = theta_dot
        print(f"\\nFixed point: theta_dot* = "
              f"{theta_dot:.4f} rad/s")
        break
    theta_dot = td_out

eps = 0.001
rho_prime = (
    compute_poincare_map(theta_dot + eps)
    - compute_poincare_map(theta_dot - eps)
) / (2 * eps)
print(f"Poincare map derivative: |rho'| = "
      f"{abs(rho_prime):.4f}")
if abs(rho_prime) < 1:
    print("Gait is LOCALLY STABLE")
else:
    print("Gait is UNSTABLE")

# --- Plot return map, fixed point, and cobweb ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def plot_poincare_cobweb(fp, rho_d):
    """Plot return map P(x), y=x, and cobweb."""
    xr = np.linspace(0.5, 3.0, 200)
    pv = [compute_poincare_map(x) for x in xr]
    fig, ax = plt.subplots(figsize=(7, 6))
    ax.plot(xr, pv, "b-", linewidth=2,
            label="Return map P(x)")
    ax.plot(xr, xr, "k--", linewidth=1,
            label="y = x (identity)")
    ax.plot(fp, fp, "ro", markersize=12, zorder=5,
            label=f"Fixed point = {fp:.3f}")
    xc = 1.5
    cx, cy = [xc], [0]
    for _ in range(12):
        yn = compute_poincare_map(xc)
        cx.extend([xc, yn])
        cy.extend([yn, yn])
        xc = yn
    ax.plot(cx, cy, "m-", linewidth=0.8,
            alpha=0.7, label="Cobweb iteration")
    ax.set_xlabel("theta_dot_n (rad/s)")
    ax.set_ylabel("theta_dot_n+1 (rad/s)")
    ax.set_title("Poincare Return Map  |rho'| = "
                 + f"{abs(rho_d):.4f}")
    ax.legend(fontsize=8)
    ax.grid(True, alpha=0.3)
    ax.set_aspect("equal")
    fig.tight_layout()
    return fig

if fixed_point is not None:
    fig = plot_poincare_cobweb(fixed_point, rho_prime)
    buf = io.BytesIO()
    fig.savefig(buf, format="png", dpi=100,
                bbox_inches="tight")
    buf.seek(0)
    img = base64.b64encode(buf.read()).decode("utf-8")
    print(f"data:image/png;base64,{img}")
    plt.close()
`}
/>

## シミュレーション: ゼロダイナミクス位相ポートレート

ゼロダイナミクスは、仮想制約が実現された後に残る1自由度システムを記述します。その位相ポートレートは歩行の構造を明らかにします。安定なリミットサイクルは、近傍の軌道を引き付ける閉軌道として現れます。

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

g = 9.81
l = 0.8
m_h = 5.0
m_l = 1.0
slope = 0.05

def compute_zd_accel(theta, dtheta):
    """Compute acceleration on zero dynamics surface."""
    grav = (m_h+m_l)*g*math.sin(theta-slope)/l
    damp = 0.05 * dtheta
    return (-grav - damp) / (m_h + m_l)

def simulate_zd(th0, dth0, dt=0.001, n_max=5000):
    """Integrate zero dynamics from initial condition."""
    ths, dths = [th0], [dth0]
    th, dth = th0, dth0
    for _ in range(n_max):
        ddth = compute_zd_accel(th, dth)
        dth += ddth * dt
        th += dth * dt
        ths.append(th)
        dths.append(dth)
        if th >= 0.2 or dth < 0:
            break
    return ths, dths

def apply_impact(dtheta, step_length=0.3):
    """Apply impact map and leg relabeling."""
    ha = math.asin(step_length / (2 * l))
    return -0.2, dtheta * abs(math.cos(2 * ha))

ics = [
    (-0.2, 0.8, "tab:blue"),
    (-0.2, 1.2, "tab:orange"),
    (-0.2, 1.6, "tab:green"),
    (-0.2, 2.0, "tab:red"),
    (-0.2, 0.5, "tab:purple"),
]

fig, ax = plt.subplots(figsize=(7, 6))
for th0, dth0, color in ics:
    a_th, a_dth = [], []
    t_ic, d_ic = th0, dth0
    for _ in range(8):
        tl, dl = simulate_zd(t_ic, d_ic)
        a_th.extend(tl)
        a_dth.extend(dl)
        if dl[-1] <= 0:
            break
        t_ic, d_ic = apply_impact(dl[-1])
    ax.plot(a_th, a_dth, color=color,
            linewidth=1.2, alpha=0.8,
            label=f"dtheta0 = {dth0:.1f}")
    ax.plot(a_th[0], a_dth[0], "o",
            color=color, markersize=6)

ax.set_xlabel("theta (rad)")
ax.set_ylabel("dtheta/dt (rad/s)")
ax.set_title("Zero Dynamics Phase Portrait")
ax.legend(fontsize=8, loc="upper left")
ax.grid(True, alpha=0.3)
ax.axvline(x=0.2, color="gray", linestyle=":",
           linewidth=1)
fig.tight_layout()
buf = io.BytesIO()
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()

print()
print("=== Zero Dynamics Phase Portrait ===")
print("Each trajectory starts from theta = -0.2 rad")
print("with different initial angular velocities.")
print()
print("Trajectories that are too slow stall before")
print("reaching the impact surface (theta = 0.2).")
print("Trajectories near the stable gait converge")
print("to a limit cycle across multiple steps.")
`}
/>

## HZDの利点

1. **証明可能な安定性**: 厳密なポアンカレ解析により安定性を保証
2. **時間非依存**: 位相ベースのパラメータ化が速度変動に対応
3. **低次元解析**: ゼロダイナミクスにより安定性問題を低次元化
4. **最適化に適している**: ベジエ係数は滑らかな最適化変数
5. **実機で検証済み**: Cassie、Digit、MABELで実証成功

## 他の章との関連

- **受動歩行（第4章）**: HZDは受動歩行理論からポアンカレ写像解析の枠組みを継承しています。HZD歩容の安定性は、斜面上の受動歩行と全く同様に、線形化されたポアンカレリターンマップの固有値を計算することで評価されます。
- **強化学習（第11章）**: HZDの仮想制約は、RL方策の出力構造として利用できます。生のトルクを学習する代わりに、RLエージェントが仮想制約を定義するベジエ係数 $\alpha_k$ を学習できます。これにより探索空間が大幅に削減され、より高速でロバストな学習につながります。

## 参考文献

- E. Westervelt et al., "[Hybrid zero dynamics of planar biped walkers](https://doi.org/10.1109/TAC.2003.814636)," *IEEE Trans. Automatic Control*, 2003.
- A. Ames et al., "[Human-Inspired Control of Bipedal Walking Robots](https://doi.org/10.1109/TAC.2014.2299342)," *IEEE Trans. Automatic Control*, 2014.
- J. Grizzle et al., "[MABEL, A New Robotic Bipedal Walker and Runner](https://doi.org/10.1109/ACC.2009.5160550)," *Proc. ACC*, 2009.

<InteractiveDemo title="Virtual Constraint Design">
  <p className="text-sm text-gray-500">
    Interactive virtual constraint design with Bezier polynomial editor coming soon.
  </p>
</InteractiveDemo>
