import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { PassiveWalkerDiagram, PoincareDiagram } from "@/components/diagrams/PassiveWalkerDiagram";
import { PassiveWalkerAnimationDiagram } from "@/components/diagrams/PassiveWalkerAnimationDiagram";

# 受動歩行

受動歩行は、二足歩行が必ずしも能動的な制御を必要としないことを示します。
1990年にTad McGeerによって開拓された受動歩行器は、重力と力学的ダイナミクスを利用して、
モーターやコントローラーなしで緩い斜面を歩きます。

## McGeerの受動歩行機

McGeerは、単純な二脚機構が重力のみを使って安定して斜面を歩行できることを示しました。
重要な知見: **歩行は本質的に制御された転倒の過程である**。

最小限の受動歩行器は以下で構成されます:
- 股関節で接続された2本の剛体脚
- 点状の足（または安定性のための湾曲した足）
- 重力エネルギーを供給する緩い斜面

<PassiveWalkerDiagram />

<PassiveWalkerAnimationDiagram />

## ハイブリッド力学系

受動歩行は**ハイブリッド力学系**です。以下の要素を組み合わせます:

1. **連続力学**（遊脚期）: 微分方程式により支配される
1. **離散イベント**（踵接地）: 瞬間的な速度変化

### 遊脚期の力学

脚長 $l$、股関節質量 $M$、足部質量 $m$ の平面コンパスゲート歩行器について、
傾斜角 $\gamma$ の斜面上での遊脚期の力学は:

$$
M_{\theta}(\theta)\ddot{\theta} + C_{\theta}(\theta, \dot{\theta})\dot{\theta} + G_{\theta}(\theta) = 0
$$

ここで、$\theta = [\theta_{st}, \theta_{sw}]^T$ は支持脚と遊脚の角度です。

最も単純な歩行器（股関節と足に質点がある場合）では:

$$
\ddot{\theta}_{st} = \sin(\theta_{st} - \gamma)
$$

$$
\ddot{\theta}_{sw} = \ddot{\theta}_{st} + \dot{\theta}_{st}^2 \sin(\theta_{sw}) - \cos(\theta_{st} - \gamma)\sin(\theta_{sw})
$$

> **正規化について:** 上記の方程式は $g/l = 1$、$m_H/m = 1$ と設定して正規化されています。
> これは時間が $\sqrt{l/g}$ の単位で、角度がラジアンで測定されることを意味します。
> 正規化により自由パラメータの数が減少し、傾斜角 $\gamma$ と質量比のみで
> ダイナミクスを議論できるようになります。

### 踵接地 (衝撃マップ)

踵接地時に、衝撃点まわりの角運動量が保存されます。
これにより、衝撃前から衝撃後の速度への離散写像が得られます:

$$
\dot{\theta}^+ = H(\theta^-)\dot{\theta}^-
$$

ここで、$H$ は衝撃遷移行列です:

$$
H = \begin{bmatrix} \cos(2\alpha) & 0 \\ \cos(2\alpha)(1 - \cos(2\alpha)) & 0 \end{bmatrix}
$$

衝撃時の脚間角度が $2\alpha$ の対称歩行器の場合。

### 衝撃遷移行列の導出

衝撃遷移行列 $H$ は**角運動量保存則**から導出されます。
物理的な推論を段階的に説明します:

1. **衝撃直前**、遊脚が地面に接触します。これにより新しい接触点に
   撃力的な地面反力が発生します。
1. **撃力は新しい接触点を通過する**ため、その点まわりのモーメントはゼロです。
   したがって、**新しい接触点まわりの角運動量は衝撃の前後で保存**されます。
1. 新しい支持脚足まわりの衝撃前後の角運動量を書くと:

$$
H_{after}(\theta^-) \dot{\theta}^+ = H_{before}(\theta^-) \dot{\theta}^-
$$

衝撃後の速度を解くと $\dot{\theta}^+ = H_{after}^{-1} H_{before} \dot{\theta}^-$ となります。
最も単純な質点コンパスゲート歩行器では慣性行列が簡略化され、
$H_{after}^{-1} H_{before}$ の積が上に示した遷移行列 $H$ を与えます。

重要な物理的帰結: **踵接地は常に運動エネルギーを減少させます**。
これは新しい支持脚に垂直な速度成分が瞬間的に失われるためです
（完全非弾性衝突と類似しています）。

## 受動歩行におけるエネルギー収支

斜面上の定常歩行では、優雅なエネルギー収支が成立します:
斜面を降りることで得られるエネルギーが、各踵接地衝突で失われるエネルギーに
**正確に等しく**なります。

**1歩あたりの重力によるエネルギー獲得:**

$$
\Delta E_{gain} = m g \cdot d_{step} \cdot \sin(\gamma)
$$

ここで $d_{step}$ は歩幅、$\gamma$ は傾斜角です。

**衝撃時の速度変化によるエネルギー損失:**

$$
\Delta E_{loss} = \frac{1}{2} m \left( v_{before}^2 - v_{after}^2 \right)
$$

周期歩行が存在するためには、$\Delta E_{gain} = \Delta E_{loss}$ が成り立つ必要があります。
この条件により、与えられた傾斜角に対する定常歩行速度が一意に決まります。
より急な斜面はより多くのエネルギーを供給し、
各衝撃でより大きな衝突損失を伴うより速い歩行をもたらします。

## リミットサイクル

安定な受動歩行は**リミットサイクル**に対応します。
リミットサイクルとは、近傍の軌道が収束する状態空間中の周期軌道です。

### 位相面

踵接地時の歩行器の状態は、支持脚角度 $\theta$ と角速度 $\dot{\theta}$ で記述できます。
安定な歩行パターンは $(\theta, \dot{\theta})$ 位相面上の閉軌道として現れます。

<PoincareDiagram />

## ポアンカレ写像解析

安定性を解析するために、**ポアンカレ写像** $P$ を使用します。
これはある踵接地から次の踵接地への離散時間写像です。

$$
\mathbf{x}_{n+1} = P(\mathbf{x}_n)
$$

ここで、$\mathbf{x}_n$ は $n$ 回目の踵接地時の状態です。

### 不動点と安定性

周期歩行はポアンカレ写像の**不動点** $\mathbf{x}^*$ です:

$$
\mathbf{x}^* = P(\mathbf{x}^*)
$$

ヤコビアン $\frac{\partial P}{\partial \mathbf{x}}\big|_{\mathbf{x}^*}$ の
すべての固有値の絶対値が1未満であれば、歩行は局所的に安定です。

## Python シミュレーション: 最も単純な歩行器

<CodeEditor
  initialCode={`import math

# Simplest passive walker simulation
# (rimless wheel model as a starting point)

# Parameters
g = 9.81       # gravity (m/s^2)
l = 1.0        # leg length (m)
gamma = 0.05   # slope angle (radians, about 3 degrees)
n_spokes = 5   # number of legs (rimless wheel)
alpha = math.pi / n_spokes  # half inter-leg angle

print("=== Rimless Wheel on Slope ===")
print(f"Slope angle: {math.degrees(gamma):.1f} degrees")
print(f"Number of spokes: {n_spokes}")
print(f"Half inter-leg angle: {math.degrees(alpha):.1f} degrees")
print()

# Heel strike collision: angular velocity ratio
# omega_plus / omega_minus = cos(2*alpha)
collision_ratio = math.cos(2 * alpha)
print(f"Collision velocity ratio: {collision_ratio:.4f}")

# Energy balance for steady-state rolling
# Energy gained from gravity per step = Energy lost at collision
# Steady-state angular velocity before collision:
omega_minus_sq = 2 * g / l * (1 - math.cos(2 * alpha * math.sin(gamma) / math.sin(2 * alpha)))

# Simplified for small gamma:
omega_steady = math.sqrt(2 * g * math.sin(gamma) * math.tan(alpha) / (l * (1 - collision_ratio**2)))

print(f"Steady-state angular velocity: {omega_steady:.4f} rad/s")
print()

# Simulate multiple steps
omega = omega_steady * 0.8  # start slightly slower
print("Step  omega_before  omega_after   Steady?")
print("-" * 48)

for step in range(10):
    # Swing phase: energy conservation on slope
    # omega_end^2 = omega_start^2 + 2*(g/l)*(cos(theta_end) - cos(theta_start))
    # For small angles, gain from slope:
    energy_gain = 2 * (g / l) * math.sin(gamma) * math.sin(2 * alpha)
    omega_before_strike = math.sqrt(omega**2 + energy_gain)

    # Heel strike
    omega_after_strike = collision_ratio * omega_before_strike

    converged = "~" if abs(omega_after_strike - omega_steady * collision_ratio) < 0.01 else " "
    print(f"  {step:2d}     {omega_before_strike:8.4f}      {omega_after_strike:8.4f}     {converged}")

    omega = omega_after_strike

# Plot convergence of angular velocity
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

omega_plot = omega_steady * 0.8
steps = list(range(15))
omega_before_list = []
omega_after_list = []

for s in steps:
    energy_gain_plot = 2 * (g / l) * math.sin(gamma) * math.sin(2 * alpha)
    omega_before_plot = math.sqrt(omega_plot**2 + energy_gain_plot)
    omega_after_plot = collision_ratio * omega_before_plot
    omega_before_list.append(omega_before_plot)
    omega_after_list.append(omega_after_plot)
    omega_plot = omega_after_plot

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(steps, omega_before_list, 'bo-', label='Before heel strike')
ax.plot(steps, omega_after_list, 'rs-', label='After heel strike')
ax.axhline(y=omega_steady, color='green', linestyle='--',
           label=f'Steady state = {omega_steady:.4f}')
ax.axhline(y=omega_steady * collision_ratio, color='orange',
           linestyle='--',
           label=f'Steady after strike = '
                 f'{omega_steady * collision_ratio:.4f}')
ax.set_xlabel('Step number')
ax.set_ylabel('Angular velocity (rad/s)')
ax.set_title('Rimless Wheel: Convergence of Angular Velocity')
ax.legend(fontsize=8)
ax.grid(True, alpha=0.3)
plt.tight_layout()

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## エネルギー効率

受動歩行器は、能動制御されたロボットと比較して驚くほどエネルギー効率が高いです。
**輸送コスト** (CoT) はエネルギー効率を測定します:

$$
CoT = \frac{E_{input}}{m g d}
$$

ここで、$E_{input}$ は消費エネルギー、$m$ は質量、$g$ は重力、$d$ は移動距離です。

| 歩行器の種類 | 輸送コスト |
|-------------|-----------|
| 受動歩行器 | ~0.05 |
| 人間の歩行 | ~0.20 |
| Honda ASIMO | ~3.2 |
| Boston Dynamics Atlas | ~2.0 |

受動歩行器が人間に近い効率を達成できるのは、自然な力学に逆らうのではなく、
それを活用しているからです。

## 分岐とカオス

斜面角度 $\gamma$ が増加すると、受動歩行器は**周期倍分岐**を示します。
これは非線形力学系におけるカオスへの典型的な経路です。

**物理的な意味:**

1. **小さな $\gamma$**: 歩行器は毎サイクル同一の歩を踏みます（周期1歩行）。
   各歩の歩幅と速度は同じです。
1. **中程度の $\gamma$**: 歩行器は2つの異なる歩パターンを交互に繰り返し始めます
   -- 長い歩の後に短い歩が続きます（周期2歩行）。
   さらに増加すると周期4になります: 4つの異なる歩が繰り返されます。
1. **大きな $\gamma$**: 歩行器は不規則で繰り返しのない歩を踏みます（カオス的歩行）。
   最終的にエネルギーが蓄積しすぎて転倒します。

実際のコンパスゲート歩行器はこの周期倍分岐カスケードを正確に示すことが、
Goswami et al. (1998) の数値シミュレーションで実証されています。
以下のコードは**ロジスティック写像を類推として**用いてこの概念を説明します。
ロジスティック写像 $x_{n+1} = r x_n (1 - x_n)$ は歩行器のポアンカレ写像そのものでは
ありませんが、同じ定性的な分岐構造を示すため、教育的なツールとして有用です。

<CodeEditor
  initialCode={`import math

# Demonstrate period-doubling using the logistic map as an ANALOGY.
# The actual compass-gait Poincare map shows the same bifurcation
# structure, but requires numerical ODE integration to compute.

print("=== Bifurcation Behavior (Logistic Map Analogy) ===")
print()
print("As slope increases, the walker gait transitions:")
print("  Period-1 -> Period-2 -> Period-4 -> Chaos -> Falling")
print()

# Logistic map: x_{n+1} = r * x_n * (1 - x_n)
# Parameter r plays the role of slope angle gamma
slopes = [
    (0.02, 2.8, "Period-1: every step is identical"),
    (0.04, 3.2, "Period-2: alternating long/short steps"),
    (0.06, 3.5, "Period-4: four-step repeating pattern"),
    (0.08, 3.9, "Chaos: irregular, non-repeating steps"),
]

for gamma_val, r, label in slopes:
    x = 0.5
    # Run 50 iterations to reach the attractor
    for _ in range(50):
        x = r * x * (1 - x)
    # Collect next 8 iterations
    values = []
    for _ in range(8):
        x = r * x * (1 - x)
        values.append(x)

    unique = sorted(set(round(v, 4) for v in values))
    print(f"Slope ~{gamma_val:.2f} rad (r={r}): {label}")
    print(f"  Distinct states: {len(unique)}")
    print(f"  Values: {[f'{v:.4f}' for v in unique[:4]]}")
    print()

# Plot bifurcation diagram
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

n_r = 2000
n_discard = 500
n_plot = 200
r_min, r_max = 2.5, 4.0
r_values = np.linspace(r_min, r_max, n_r)
r_plot = []
x_plot = []

for r_val in r_values:
    x = 0.5
    for _ in range(n_discard):
        x = r_val * x * (1.0 - x)
    for _ in range(n_plot):
        x = r_val * x * (1.0 - x)
        r_plot.append(r_val)
        x_plot.append(x)

fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(r_plot, x_plot, s=0.02, c='black', alpha=0.5)
ax.set_xlabel('Parameter r (analogous to slope angle)')
ax.set_ylabel('Steady-state values')
ax.set_title('Bifurcation Diagram (Logistic Map)')
ax.set_xlim(r_min, r_max)
ax.set_ylim(0, 1)
ax.grid(True, alpha=0.3)
plt.tight_layout()

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## シミュレーション: コンパスゲイト位相ポートレート

以下のシミュレーションでは、簡略化したコンパスゲイト歩行器の遊脚ダイナミクスを
4次ルンゲ・クッタ法（RK4）で数値積分します。異なる初期条件からの複数の軌道を
位相面（$\theta_{sw}$, $\dot{\theta}_{sw}$）上に重ねて描画し、軌道がリミットサイクルに
収束する様子や発散する様子を示します。

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Simplified swing leg dynamics for compass gait walker
# theta_sw'' = -sin(theta_sw) + gamma * cos(theta_sw)
# State: [theta_sw, theta_sw_dot]

gamma = 0.05  # slope angle (rad)

def swing_deriv(state):
    theta, theta_dot = state
    theta_ddot = -math.sin(theta) + gamma * math.cos(theta)
    return [theta_dot, theta_ddot]

def rk4_step(state, dt):
    k1 = swing_deriv(state)
    s2 = [state[0] + 0.5*dt*k1[0], state[1] + 0.5*dt*k1[1]]
    k2 = swing_deriv(s2)
    s3 = [state[0] + 0.5*dt*k2[0], state[1] + 0.5*dt*k2[1]]
    k3 = swing_deriv(s3)
    s4 = [state[0] + dt*k3[0], state[1] + dt*k3[1]]
    k4 = swing_deriv(s4)
    new_theta = state[0] + (dt/6)*(k1[0]+2*k2[0]+2*k3[0]+k4[0])
    new_tdot = state[1] + (dt/6)*(k1[1]+2*k2[1]+2*k3[1]+k4[1])
    return [new_theta, new_tdot]

def simulate_trajectory(theta0, tdot0, dt, n_steps):
    thetas = [theta0]
    tdots = [tdot0]
    state = [theta0, tdot0]
    for _ in range(n_steps):
        state = rk4_step(state, dt)
        thetas.append(state[0])
        tdots.append(state[1])
    return thetas, tdots

# Initial conditions: varying angle and velocity
initial_conditions = [
    (0.1, 0.0, 'blue'),
    (0.2, 0.0, 'red'),
    (0.3, 0.0, 'green'),
    (-0.1, 0.5, 'purple'),
    (-0.2, -0.3, 'orange'),
    (0.15, -0.5, 'cyan'),
    (0.05, 0.8, 'brown'),
    (-0.15, 0.6, 'magenta'),
]

dt = 0.005
n_steps = 3000

fig, ax = plt.subplots(figsize=(8, 6))

for theta0, tdot0, color in initial_conditions:
    thetas, tdots = simulate_trajectory(theta0, tdot0, dt, n_steps)
    ax.plot(thetas, tdots, color=color, alpha=0.6, linewidth=0.8)
    ax.plot(thetas[0], tdots[0], 'o', color=color, markersize=5)

ax.set_xlabel('Swing leg angle (rad)')
ax.set_ylabel('Swing leg angular velocity (rad/s)')
ax.set_title('Compass Gait: Phase Portrait of Swing Leg Dynamics'
             f' (slope = {math.degrees(gamma):.1f} deg)')
ax.grid(True, alpha=0.3)
ax.set_xlim(-0.8, 0.8)
ax.set_ylim(-1.5, 1.5)
plt.tight_layout()

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()

print()
print("Phase portrait shows swing leg trajectories from")
print("different initial conditions.")
print("Dots mark starting points. Closed orbits indicate")
print("periodic oscillations (potential limit cycles).")
print(f"Slope angle: {math.degrees(gamma):.1f} degrees")
print(f"Integration: RK4 with dt={dt}, {n_steps} steps")
`}
/>

## 受動歩行から能動歩行へ

受動歩行は能動歩行器の設計に関する知見を提供します:

1. **自然な力学の活用**: ロボットの自然な運動に逆らうのではなく、それと協調する制御器を設計する
1. **最小限のアクチュエーション**: すべての関節を制御するのではなく、適切なタイミングで少量のエネルギーを加える（例: 足首の蹴り出し）
1. **リミットサイクル安定性**: 安定な周期軌道として歩行パターンを設計する

これらの原則は、CornellのRangerやDelftのFlameなどの効率的な歩行ロボットの開発に影響を与えました。

### 他の章との関連

- **ハイブリッド零力学 (第9章):** HZDは能動制御された歩行の安定性解析に
  同じポアンカレ写像のフレームワークを使用します。
  主な違いは、HZDがリミットサイクルを整形するためにフィードバック制御を追加するのに対し、
  受動歩行器は完全に開ループダイナミクスに依存する点です。
- **強化学習 (第11章):** RLベースの移動制御器は、受動歩行に類似した
  エネルギー効率の高い歩行パターンを発見できます。
  輸送コストの指標が受動歩行理論とRLの報酬設計を結びつけます。
- **中枢パターン生成器 (第7章):** CPGは受動歩行器で観察されるリミットサイクル構造を
  再現するリズミックな運動パターンを生成します。
  両アプローチとも、安定な移動が周期的な振動ダイナミクスから創発するという
  考えを共有しています。

## 参考文献

- T. McGeer, "[Passive Dynamic Walking](https://doi.org/10.1177/027836499000900206)," *Int. J. Robotics Research*, 1990.
- A. Goswami et al., "[Limit Cycles in a Passive Compass Gait Biped and Passivity-Mimicking Control Laws](https://doi.org/10.1023/A:1008844026298)," *Autonomous Robots*, 1997.
- S. Collins et al., "[Efficient Bipedal Robots Based on Passive-Dynamic Walkers](https://doi.org/10.1126/science.1107799)," *Science*, 2005.

<InteractiveDemo title="Passive Walker Simulation">
  <p className="text-sm text-gray-500">
    Interactive passive walker on adjustable slope coming soon.
  </p>
</InteractiveDemo>
