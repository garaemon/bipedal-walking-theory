import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { RigidBodyDiagram, DoublePendulumDiagram } from "@/components/diagrams/RigidBodyDiagram";
import { FrictionConeDiagram } from "@/components/diagrams/FrictionConeDiagram";

# 剛体力学

本章では、二足歩行に関連する剛体力学の基礎を扱います。
これらの基礎を理解することは、歩行ロボットのモデリングと制御にとって不可欠です。

## ニュートン・オイラー方程式

剛体の運動は、並進運動に関するニュートンの第二法則と、回転運動に関するオイラーの方程式によって支配されます。

並進運動について:

$$
\mathbf{F} = m\mathbf{a}
$$

ここで、$\mathbf{F}$ は合力、$m$ は質量、$\mathbf{a}$ は重心の加速度です。

重心まわりの回転運動について:

$$
\boldsymbol{\tau} = \mathbf{I}\boldsymbol{\alpha} + \boldsymbol{\omega} \times \mathbf{I}\boldsymbol{\omega}
$$

ここで、$\boldsymbol{\tau}$ は合トルク、$\mathbf{I}$ は慣性テンソル、
$\boldsymbol{\alpha}$ は角加速度、$\boldsymbol{\omega}$ は角速度です。

$\boldsymbol{\omega} \times \mathbf{I}\boldsymbol{\omega}$ の項は**ジャイロスコピック効果**であり、
異なる軸の回転運動を結合し、3次元歩行力学において重要な役割を果たします。

<RigidBodyDiagram />

## 慣性テンソル

慣性テンソル $\mathbf{I}$ は、回転軸に対する質量分布を表します:

$$
\mathbf{I} = \begin{bmatrix}
I_{xx} & -I_{xy} & -I_{xz} \\
-I_{xy} & I_{yy} & -I_{yz} \\
-I_{xz} & -I_{yz} & I_{zz}
\end{bmatrix}
$$

対角要素は**慣性モーメント**、非対角要素は**慣性乗積**です。各要素は物体の質量分布にわたる積分として定義されます。例えば、物体内の位置 $(x, y, z)$ にある微小質量要素 $dm$ を考えます。$x$ 軸まわりの慣性モーメントは:

$$
I_{xx} = \int (y^2 + z^2) \, dm
$$

被積分関数 $(y^2 + z^2)$ は $x$ 軸からの距離の二乗であり、$I_{xx}$ はその軸からの質量の広がりを測定します。同様に:

$$
I_{yy} = \int (x^2 + z^2) \, dm, \quad I_{zz} = \int (x^2 + y^2) \, dm
$$

非対角の**慣性乗積**は質量分布の非対称性を捉えます:

$$
I_{xy} = \int xy \, dm, \quad I_{xz} = \int xz \, dm, \quad I_{yz} = \int yz \, dm
$$

物体が対称性を持つ場合（例: 軸に沿った円柱）、これらの乗積項は消え、慣性テンソルは対角行列になります。

質量 $m$、半径 $r$、長さ $h$ の中実円柱（ロボットの肢セグメントの一般的な近似）の場合:

$$
I_{xx} = I_{yy} = \frac{1}{12}m(3r^2 + h^2), \quad I_{zz} = \frac{1}{2}mr^2
$$

### 平行軸の定理

回転軸が重心から距離 $d$ だけ離れている場合:

$$
I_{axis} = I_{cm} + md^2
$$

これは、複合的なロボットリンクの慣性を計算するために不可欠です。

<CodeEditor
  initialCode={`import math

# Inertia tensor computation for a robot leg
# Modeled as two cylinders (thigh + shank)

# Thigh parameters
m_thigh = 3.0      # mass (kg)
r_thigh = 0.04     # radius (m)
h_thigh = 0.40     # length (m)

# Shank parameters
m_shank = 2.0
r_shank = 0.03
h_shank = 0.35

def compute_cylinder_inertia(m, r, h):
    """Compute moments of inertia for a solid cylinder about its CoM."""
    Ixx = (1/12) * m * (3 * r**2 + h**2)
    Iyy = Ixx
    Izz = 0.5 * m * r**2
    return Ixx, Iyy, Izz

Ixx_t, Iyy_t, Izz_t = compute_cylinder_inertia(m_thigh, r_thigh, h_thigh)
Ixx_s, Iyy_s, Izz_s = compute_cylinder_inertia(m_shank, r_shank, h_shank)

print("=== Robot Leg Inertia Properties ===")
print(f"\\nThigh (m={m_thigh}kg, r={r_thigh}m, h={h_thigh}m):")
print(f"  Ixx = Iyy = {Ixx_t:.6f} kg*m^2")
print(f"  Izz = {Izz_t:.6f} kg*m^2")

print(f"\\nShank (m={m_shank}kg, r={r_shank}m, h={h_shank}m):")
print(f"  Ixx = Iyy = {Ixx_s:.6f} kg*m^2")
print(f"  Izz = {Izz_s:.6f} kg*m^2")

# Parallel axis theorem: shank inertia about hip
d_shank = h_thigh + h_shank / 2
Ixx_shank_hip = Ixx_s + m_shank * d_shank**2

print(f"\\n=== Parallel Axis Theorem ===")
print(f"Shank CoM distance from hip: {d_shank:.3f} m")
print(f"Shank Ixx about hip: {Ixx_shank_hip:.6f} kg*m^2")
print(f"  (vs about own CoM: {Ixx_s:.6f} kg*m^2)")
print(f"  Ratio: {Ixx_shank_hip/Ixx_s:.1f}x increase")

# --- Bar chart of moments of inertia ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def plot_inertia_bar_chart(thigh_inertia, shank_inertia):
    """Plot a grouped bar chart comparing thigh and shank inertia."""
    labels = ["Ixx (= Iyy)", "Izz"]
    thigh_vals = [thigh_inertia[0], thigh_inertia[2]]
    shank_vals = [shank_inertia[0], shank_inertia[2]]

    x = np.arange(len(labels))
    width = 0.3
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.bar(x - width/2, thigh_vals, width, label="Thigh", color="#2563eb")
    ax.bar(x + width/2, shank_vals, width, label="Shank", color="#dc2626")
    ax.set_ylabel("Moment of Inertia (kg*m^2)")
    ax.set_title("Robot Leg Inertia Comparison")
    ax.set_xticks(x)
    ax.set_xticklabels(labels)
    ax.legend()
    ax.grid(axis="y", alpha=0.3)
    plt.tight_layout()
    return fig

fig = plot_inertia_bar_chart(
    (Ixx_t, Iyy_t, Izz_t),
    (Ixx_s, Iyy_s, Izz_s),
)
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## 多関節体の運動方程式

$n$ 個の関節を持つロボットの関節空間における運動方程式は次のとおりです:

<MathBlock tex="M(\mathbf{q})\ddot{\mathbf{q}} + \mathbf{C}(\mathbf{q}, \dot{\mathbf{q}})\dot{\mathbf{q}} + \mathbf{g}(\mathbf{q}) = \boldsymbol{\tau}" />

ここで:
- $\mathbf{q} \in \mathbb{R}^n$: 関節角度
- $M(\mathbf{q}) \in \mathbb{R}^{n \times n}$: 質量（慣性）行列 — 対称かつ正定値
- $\mathbf{C}(\mathbf{q}, \dot{\mathbf{q}})\dot{\mathbf{q}}$: コリオリ力と遠心力
- $\mathbf{g}(\mathbf{q})$: 重力
- $\boldsymbol{\tau}$: 関節トルク

### 質量行列の性質

質量行列 $M(\mathbf{q})$ は重要な性質を持ちます:
1. **対称性**: $M = M^T$
2. **正定値性**: すべての $\mathbf{x} \neq 0$ に対して $\mathbf{x}^T M \mathbf{x} > 0$
3. **構成依存性**: 関節角度に応じて変化する

### コリオリ行列

コリオリ行列は**第一種クリストッフェル記号**から計算できます:

$$
C_{ij} = \sum_{k=1}^{n} c_{ijk} \dot{q}_k, \quad c_{ijk} = \frac{1}{2}\left(\frac{\partial M_{ij}}{\partial q_k} + \frac{\partial M_{ik}}{\partial q_j} - \frac{\partial M_{jk}}{\partial q_i}\right)
$$

この偏微分の特定の組み合わせは恣意的なものではありません。$\dot{M} - 2C$ が**歪対称**（すなわち、すべての $\mathbf{x}$ に対して $\mathbf{x}^T (\dot{M} - 2C) \mathbf{x} = 0$）となるように選ばれています。この性質により、運動エネルギーの変化率が外力による仕事率に等しいことが保証されます:

$$
\frac{d}{dt}\left(\frac{1}{2}\dot{\mathbf{q}}^T M \dot{\mathbf{q}}\right) = \dot{\mathbf{q}}^T \boldsymbol{\tau} - \dot{\mathbf{q}}^T \mathbf{g}
$$

コリオリ項は関節間でエネルギーを再配分しますが、エネルギーの生成も消滅もしません。この**受動性**は多くのロボット制御器の安定性証明の基礎となります。

## 順動力学と逆動力学

2つの基本的な計算問題があります:

**順動力学**: 関節トルク $\boldsymbol{\tau}$ が与えられたとき、加速度 $\ddot{\mathbf{q}}$ を計算する:

$$
\ddot{\mathbf{q}} = M(\mathbf{q})^{-1}(\boldsymbol{\tau} - \mathbf{C}\dot{\mathbf{q}} - \mathbf{g})
$$

**逆動力学**: 目標加速度 $\ddot{\mathbf{q}}$ が与えられたとき、必要なトルクを計算する:

$$
\boldsymbol{\tau} = M(\mathbf{q})\ddot{\mathbf{q}} + \mathbf{C}\dot{\mathbf{q}} + \mathbf{g}
$$

順動力学はシミュレーションに、逆動力学は制御に使用されます。

## 接触力と摩擦

歩行ロボットが地面と接触するとき、運動方程式に追加の力が加わります:

$$
M(\mathbf{q})\ddot{\mathbf{q}} + \mathbf{C}\dot{\mathbf{q}} + \mathbf{g} = \boldsymbol{\tau} + \mathbf{J}_c^T \mathbf{f}_c
$$

ここで、$\mathbf{f}_c$ は接触力ベクトル、$\mathbf{J}_c$ は**接触ヤコビアン**です。接触ヤコビアンは関節速度と接触点の速度を関係づけます:

$$
\mathbf{v}_c = \mathbf{J}_c(\mathbf{q}) \, \dot{\mathbf{q}}
$$

ここで $\mathbf{v}_c$ はデカルト空間における接触点の線速度です。転置 $\mathbf{J}_c^T$ は仮想仕事の原理に基づき、デカルト空間の接触力を等価な関節トルクに写像します。接触点での仕事率（$\mathbf{f}_c^T \mathbf{v}_c$）と関節での仕事率（$\boldsymbol{\tau}_c^T \dot{\mathbf{q}}$）が等しいことから、$\boldsymbol{\tau}_c = \mathbf{J}_c^T \mathbf{f}_c$ が得られます。

### クーロン摩擦モデル

摩擦力 $f_t$ は垂直抗力 $f_n$ によって制限されます:

$$
|f_t| \leq \mu f_n
$$

ここで、$\mu$ は摩擦係数です。この拘束条件は**摩擦錐**を定義します。
安定した歩行のためには、地面反力が摩擦錐の内部に留まる必要があります。

<FrictionConeDiagram />

## 例: 二重振子

二重振子は、2リンク脚の最小限のモデルです:

<DoublePendulumDiagram />

<CodeEditor
  initialCode={`import math

# Double pendulum dynamics
# (simplified model of a two-link robot leg)

# Parameters
m1, m2 = 3.0, 2.0      # link masses (kg)
l1, l2 = 0.4, 0.35      # link lengths (m)
lc1, lc2 = l1/2, l2/2   # CoM distances from joints
I1 = m1 * l1**2 / 12    # link inertias
I2 = m2 * l2**2 / 12
g = 9.81

def compute_mass_matrix(q1, q2):
    """Compute 2x2 mass matrix for double pendulum."""
    c2 = math.cos(q2)
    M11 = (m1 * lc1**2 + I1 + m2 * (l1**2 + lc2**2 + 2*l1*lc2*c2) + I2)
    M12 = m2 * (lc2**2 + l1*lc2*c2) + I2
    M21 = M12
    M22 = m2 * lc2**2 + I2
    return M11, M12, M21, M22

def compute_gravity_vector(q1, q2):
    """Compute gravity torques."""
    g1 = (m1*lc1 + m2*l1) * g * math.sin(q1) + m2*lc2*g*math.sin(q1+q2)
    g2 = m2*lc2*g*math.sin(q1+q2)
    return g1, g2

# Evaluate at a specific configuration
q1 = math.pi/4   # 45 degrees
q2 = -math.pi/6  # -30 degrees

M11, M12, M21, M22 = compute_mass_matrix(q1, q2)
g1, g2 = compute_gravity_vector(q1, q2)

print("=== Double Pendulum at q1=45deg, q2=-30deg ===")
print(f"\\nMass matrix:")
print(f"  M = [{M11:.4f}  {M12:.4f}]")
print(f"      [{M21:.4f}  {M22:.4f}]")
print(f"\\nGravity torques:")
print(f"  g1 = {g1:.4f} N*m  (hip)")
print(f"  g2 = {g2:.4f} N*m  (knee)")

# Inverse dynamics: what torques needed to hold this pose?
print(f"\\nTo hold this pose statically:")
print(f"  tau_hip  = {g1:.4f} N*m")
print(f"  tau_knee = {g2:.4f} N*m")

det = M11 * M22 - M12 * M21
print(f"\\nMass matrix determinant: {det:.6f}")
print(f"Mass matrix is {'positive definite' if det > 0 else 'NOT positive definite'}")

# --- Stick figure of the double pendulum configuration ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def compute_joint_positions(q1, q2, l1, l2):
    """Compute (x, y) positions of shoulder, elbow, and end-effector."""
    x1 = l1 * math.sin(q1)
    y1 = -l1 * math.cos(q1)
    x2 = x1 + l2 * math.sin(q1 + q2)
    y2 = y1 - l2 * math.cos(q1 + q2)
    return (0, 0), (x1, y1), (x2, y2)

def plot_stick_figure(q1, q2, l1, l2):
    """Draw the double pendulum as a stick figure with joint labels."""
    p0, p1, p2 = compute_joint_positions(q1, q2, l1, l2)

    fig, ax = plt.subplots(figsize=(5, 5))
    # Draw links
    ax.plot([p0[0], p1[0]], [p0[1], p1[1]],
            "o-", color="#2563eb", lw=4, markersize=8, label="Link 1")
    ax.plot([p1[0], p2[0]], [p1[1], p2[1]],
            "o-", color="#dc2626", lw=4, markersize=8, label="Link 2")
    # Mark pivot
    ax.plot(p0[0], p0[1], "ks", markersize=12, label="Pivot")
    # Labels
    ax.annotate("Hip (pivot)", xy=p0, xytext=(0.05, 0.05),
                fontsize=9, fontweight="bold")
    ax.annotate("Knee", xy=p1, xytext=(p1[0]+0.03, p1[1]+0.03),
                fontsize=9, fontweight="bold")
    ax.annotate("End-effector", xy=p2, xytext=(p2[0]+0.03, p2[1]+0.03),
                fontsize=9, fontweight="bold")

    limit = l1 + l2 + 0.1
    ax.set_xlim(-limit, limit)
    ax.set_ylim(-limit, limit * 0.3)
    ax.set_aspect("equal")
    ax.grid(True, alpha=0.3)
    ax.set_xlabel("x (m)")
    ax.set_ylabel("y (m)")
    ax.set_title("Double Pendulum Configuration (q1=45, q2=-30 deg)")
    ax.legend(loc="upper right", fontsize=8)
    plt.tight_layout()
    return fig

fig = plot_stick_figure(q1, q2, l1, l2)
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## シミュレーション: 二重振子の順動力学

以下のシミュレーションは、4次のルンゲ・クッタ法（RK4）を用いて二重振子の運動方程式を積分します。
重力下でトルク入力ゼロの初期状態から、振子が時間とともにどのように変化するかを示します。
左のパネルは関節角度を、右のパネルはデカルト空間における先端の軌跡を描画します。

<CodeEditor
  initialCode={`import math
import numpy as np

# === Physical parameters ===
m1, m2 = 3.0, 2.0
l1, l2 = 0.4, 0.35
lc1, lc2 = l1 / 2, l2 / 2
I1 = m1 * l1**2 / 12
I2 = m2 * l2**2 / 12
gravity = 9.81

def compute_mass_matrix(q1, q2):
    """Return 2x2 mass matrix entries."""
    c2 = math.cos(q2)
    M11 = m1*lc1**2 + I1 + m2*(l1**2 + lc2**2 + 2*l1*lc2*c2) + I2
    M12 = m2*(lc2**2 + l1*lc2*c2) + I2
    M22 = m2*lc2**2 + I2
    return M11, M12, M12, M22

def compute_coriolis_vector(q1, q2, dq1, dq2):
    """Return Coriolis/centrifugal torque vector."""
    s2 = math.sin(q2)
    h = m2 * l1 * lc2 * s2
    c1 = -h * dq2 * (2*dq1 + dq2)
    c2 = h * dq1**2
    return c1, c2

def compute_gravity_torques(q1, q2):
    """Return gravity torque vector."""
    g1 = (m1*lc1 + m2*l1)*gravity*math.sin(q1) + m2*lc2*gravity*math.sin(q1+q2)
    g2 = m2*lc2*gravity*math.sin(q1+q2)
    return g1, g2

def compute_accelerations(q1, q2, dq1, dq2):
    """Solve forward dynamics: M * ddq = -C - g (zero torque)."""
    M11, M12, M21, M22 = compute_mass_matrix(q1, q2)
    c1, c2 = compute_coriolis_vector(q1, q2, dq1, dq2)
    g1, g2 = compute_gravity_torques(q1, q2)
    rhs1 = -c1 - g1
    rhs2 = -c2 - g2
    det = M11 * M22 - M12 * M21
    ddq1 = (M22 * rhs1 - M12 * rhs2) / det
    ddq2 = (-M21 * rhs1 + M11 * rhs2) / det
    return ddq1, ddq2

def rk4_step(state, dt):
    """Advance one RK4 step for [q1, q2, dq1, dq2]."""
    def derivs(s):
        ddq1, ddq2 = compute_accelerations(s[0], s[1], s[2], s[3])
        return np.array([s[2], s[3], ddq1, ddq2])
    k1 = derivs(state)
    k2 = derivs(state + 0.5 * dt * k1)
    k3 = derivs(state + 0.5 * dt * k2)
    k4 = derivs(state + dt * k3)
    return state + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)

def run_simulation(q1_init, q2_init, t_end, dt):
    """Integrate the double pendulum ODE and return time history."""
    n_steps = int(t_end / dt)
    state = np.array([q1_init, q2_init, 0.0, 0.0])
    time_hist = np.zeros(n_steps + 1)
    q_hist = np.zeros((n_steps + 1, 2))
    q_hist[0] = [state[0], state[1]]
    for i in range(n_steps):
        state = rk4_step(state, dt)
        time_hist[i + 1] = (i + 1) * dt
        q_hist[i + 1] = [state[0], state[1]]
    return time_hist, q_hist

def compute_end_effector(q1_arr, q2_arr, l1, l2):
    """Compute end-effector (x, y) from joint angle arrays."""
    x1 = l1 * np.sin(q1_arr)
    y1 = -l1 * np.cos(q1_arr)
    x2 = x1 + l2 * np.sin(q1_arr + q2_arr)
    y2 = y1 - l2 * np.cos(q1_arr + q2_arr)
    return x2, y2

# --- Run simulation ---
t_end = 3.0
dt = 0.002
q1_init = math.pi / 4
q2_init = -math.pi / 6
time_hist, q_hist = run_simulation(q1_init, q2_init, t_end, dt)
ee_x, ee_y = compute_end_effector(q_hist[:, 0], q_hist[:, 1], l1, l2)

print("=== Double Pendulum Forward Dynamics (RK4) ===")
print(f"Initial angles: q1={math.degrees(q1_init):.0f} deg, q2={math.degrees(q2_init):.0f} deg")
print(f"Simulation time: {t_end} s, dt={dt} s")
print(f"Final angles: q1={math.degrees(q_hist[-1,0]):.1f} deg, q2={math.degrees(q_hist[-1,1]):.1f} deg")

# --- Plot results ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import io, base64

def plot_forward_dynamics(time_hist, q_hist, ee_x, ee_y):
    """Create a 2-panel figure: joint angles and end-effector trajectory."""
    fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(10, 4))

    # Panel 1: Joint angles vs time
    ax1.plot(time_hist, np.degrees(q_hist[:, 0]), label="q1 (hip)", color="#2563eb")
    ax1.plot(time_hist, np.degrees(q_hist[:, 1]), label="q2 (knee)", color="#dc2626")
    ax1.set_xlabel("Time (s)")
    ax1.set_ylabel("Joint Angle (deg)")
    ax1.set_title("Joint Angles vs Time")
    ax1.legend()
    ax1.grid(True, alpha=0.3)

    # Panel 2: End-effector trajectory
    ax2.plot(ee_x, ee_y, color="#059669", lw=0.5, alpha=0.7)
    ax2.plot(ee_x[0], ee_y[0], "go", markersize=8, label="Start")
    ax2.plot(ee_x[-1], ee_y[-1], "rs", markersize=8, label="End")
    ax2.set_xlabel("x (m)")
    ax2.set_ylabel("y (m)")
    ax2.set_title("End-Effector Trajectory")
    ax2.set_aspect("equal")
    ax2.legend()
    ax2.grid(True, alpha=0.3)

    plt.tight_layout()
    return fig

fig = plot_forward_dynamics(time_hist, q_hist, ee_x, ee_y)
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## まとめ

本章の主要な概念は、二足歩行全体を通じて繰り返し登場します:

1. **ニュートン・オイラー方程式**は並進と回転における剛体の運動を記述する
2. **慣性テンソル**は質量分布を特徴づける
3. **運動方程式** $M\ddot{q} + C\dot{q} + g = \tau$ は多関節ロボットを支配する
4. **接触力**と摩擦拘束は地面との相互作用に不可欠である
5. **順動力学/逆動力学**はシミュレーションと制御の核となる計算手法である

## 参考文献

- R. Featherstone, [*Rigid Body Dynamics Algorithms*](https://link.springer.com/book/10.1007/978-1-4899-7560-7), Springer, 2008.
- R. Murray, Z. Li, and S. Sastry, [*A Mathematical Introduction to Robotic Manipulation*](https://www.cds.caltech.edu/~murray/mlswiki/index.php/Main_Page), CRC Press, 1994.

<InteractiveDemo title="Rigid Body Simulation">
  <p className="text-sm text-gray-500">
    Interactive 3D rigid body simulation with adjustable parameters coming soon.
  </p>
</InteractiveDemo>
