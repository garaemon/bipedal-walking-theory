import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { CapturePointDiagram, DCMWalkingDiagram } from "@/components/diagrams/CapturePointDiagram";
import { DCMPhaseDiagram } from "@/components/diagrams/DCMPhaseDiagram";

# キャプチャポイントとDCM

キャプチャポイント（発散運動成分とも呼ばれる）は、二足歩行のバランスを理解し、押し回復戦略を設計するための直感的なフレームワークを提供します。これは根本的な問いに答えます: *ロボットが転倒を避けるためにはどこに足を踏み出すべきか？*

## キャプチャポイントの定義

**キャプチャポイント** $\boldsymbol{\xi}$ は、ロボットが瞬時に足を置くことで完全に停止できる地面上の点です。

<MathBlock tex="\boldsymbol{\xi} = \mathbf{x} + \frac{1}{\omega}\dot{\mathbf{x}}" />

ここで $\mathbf{x}$ は重心位置、$\dot{\mathbf{x}}$ は重心速度、$\omega = \sqrt{g/z_c}$ はLIPMの固有周波数です。

<CapturePointDiagram />

### 直感的理解

- ロボットが $\boldsymbol{\xi}$ の位置に正確に足を置くと、重心は減速して足の真上で停止します
- キャプチャポイントは常に重心の**前方**（運動方向）にあります
- 速度が大きいほど $\boldsymbol{\xi}$ はさらに前方に移動します

## 発散運動成分 (DCM)

DCMはキャプチャポイントと数学的に同一です。この名称は、LIPMのダイナミクスを**安定**成分と**不安定**成分に分解することに由来します。

LIPMの方程式 $\ddot{x} = \omega^2(x - r)$（$r$ はCoPとする）から出発します。これは二次系です。分解するために、新しい座標を定義します:

$$
\xi = x + \frac{\dot{x}}{\omega} \quad \text{(DCM / unstable component)}
$$

$$
\zeta = x - \frac{\dot{x}}{\omega} \quad \text{(stable component)}
$$

$x = \frac{1}{2}(\xi + \zeta)$ かつ $\dot{x} = \frac{\omega}{2}(\xi - \zeta)$ であるため、これは可逆な座標変換です。

### DCMダイナミクス

$\xi = x + \dot{x}/\omega$ を微分し、$\ddot{x} = \omega^2(x - r)$ を代入すると:

$$
\dot{\xi} = \dot{x} + \frac{\ddot{x}}{\omega} = \dot{x} + \omega(x - r) = \omega\left(x + \frac{\dot{x}}{\omega} - r\right) = \omega(\xi - r)
$$

同様に $\dot{\zeta} = -\omega(\zeta - r)$ が得られます。二次のLIPMが二つの**独立な**一次系に分解されました:
- $\dot{\xi} = +\omega(\xi - r)$: **不安定**（$r$ から発散する）
- $\dot{\zeta} = -\omega(\zeta - r)$: **安定**（$r$ に収束する）

安定成分 $\zeta$ は自然に収束するので、制御器は不安定なDCM $\xi$ のみを管理すればよいのです。これがDCMベースの制御が効果的な理由です。

<DCMPhaseDiagram />

CoP $r$ がDCMの制御入力として機能します。

### DCMによる重心ダイナミクス

重心は一次安定ダイナミクスでDCMに追従します:

$$
\dot{x} = -\omega(x - \xi)
$$

これは重心が常にDCMに収束することを意味し、制御設計にとって強力な性質です。

## 押し回復

押されると、ロボットのDCMがシフトします。回復戦略は以下の通りです:

1. **足首戦略**: 足の中でCoPを調整してDCMを誘導
2. **踏み出し戦略**: 新しいキャプチャポイントに足を置く
3. **腰戦略**: 角運動量を利用してDCMをシフト

<CodeEditor
  initialCode={`import math

# Push recovery using capture point
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)

# Initial state (standing still)
x = 0.0      # CoM position
xdot = 0.0   # CoM velocity

# Compute capture point
xi = x + xdot / omega
print("=== Before Push ===")
print(f"CoM: {x:.3f} m, Vel: {xdot:.3f} m/s")
print(f"Capture Point: {xi:.3f} m")
print()

# Apply a push (impulse changes velocity)
push_impulse = 0.3  # m/s velocity change
xdot += push_impulse

xi = x + xdot / omega
print("=== After Push ===")
print(f"CoM: {x:.3f} m, Vel: {xdot:.3f} m/s")
print(f"Capture Point: {xi:.4f} m")
print()

# Foot size (can the ankle strategy handle it?)
foot_half_length = 0.12  # m
if abs(xi) <= foot_half_length:
    print(f"Ankle strategy sufficient!")
    print(f"  Move CoP to {xi:.4f} m (within foot [{-foot_half_length:.2f}, {foot_half_length:.2f}])")
else:
    print(f"Need stepping strategy!")
    print(f"  Capture point {xi:.4f} m is outside foot boundary")
    print(f"  Must step to {xi:.4f} m to recover")

print()
print("=== Recovery Simulation ===")
# Simulate recovery by stepping to capture point
r = xi  # place foot at capture point
dt = 0.01
print("Time(s)  CoM(m)   Vel(m/s)  DCM(m)")
print("-" * 42)

for i in range(100):
    t = i * dt
    # DCM dynamics: xi_dot = omega * (xi - r)
    xi_dot = omega * (xi - r)
    xi += xi_dot * dt
    # CoM dynamics: x_dot = -omega * (x - xi)
    xdot = -omega * (x - xi)
    x += xdot * dt

    if i % 10 == 0:
        print(f"{t:5.2f}    {x:7.4f}  {xdot:7.4f}   {xi:7.4f}")
`}
/>

## DCMに基づく歩行制御

<DCMWalkingDiagram />

DCM計画は最終ステップから**逆方向**に行います:

1. 最終DCM位置を選択（最後の足踏み位置）
2. 各ステップ遷移でのDCMウェイポイントを逆方向に計算
3. ウェイポイント間でDCM軌道を補間
4. 重心は自然に追従

### DCMウェイポイントの計算

ステップ $n$ の終了時に、DCMはウェイポイント $\boldsymbol{\xi}_n$ に位置するべきです。逆方向に計算すると:

$$
\boldsymbol{\xi}_n = \mathbf{r}_{n+1} + e^{-\omega T_s}(\boldsymbol{\xi}_{n+1} - \mathbf{r}_{n+1})
$$

ここで $\mathbf{r}_{n+1}$ は次の足踏み位置、$T_s$ はステップ持続時間です。

<CodeEditor
  initialCode={`import math

# DCM-based walking trajectory generation
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)
T_step = 0.6  # step duration

# Footstep positions (x-direction)
footsteps = [0.0, 0.2, 0.4, 0.6, 0.8, 0.8]

print("=== DCM Waypoint Planning (Backward) ===")
n_steps = len(footsteps)

# Final DCM = final footstep (robot stops)
dcm_waypoints = [0.0] * n_steps
dcm_waypoints[-1] = footsteps[-1]

# Compute backward
for i in range(n_steps - 2, -1, -1):
    r_next = footsteps[i + 1]
    xi_next = dcm_waypoints[i + 1]
    dcm_waypoints[i] = r_next + math.exp(-omega * T_step) * (xi_next - r_next)

print("Step  Foot(m)   DCM_waypoint(m)")
print("-" * 38)
for i in range(n_steps):
    print(f"  {i}    {footsteps[i]:.3f}     {dcm_waypoints[i]:.4f}")

# Forward simulation
print()
print("=== Forward Simulation ===")
print("Time(s)  CoM(m)   DCM(m)   CoP(m)")
print("-" * 42)

x = 0.0
xdot = 0.0
dt = 0.01
sim_steps = int(T_step * (n_steps - 1) / dt)

for k in range(sim_steps):
    t = k * dt
    step_idx = min(int(t / T_step), n_steps - 2)
    r = footsteps[step_idx]

    xi = x + xdot / omega

    # CoP to track DCM reference
    t_in_step = t - step_idx * T_step
    xi_start = dcm_waypoints[step_idx]
    xi_end = dcm_waypoints[step_idx + 1]
    xi_ref = r + (xi_start - r) * math.exp(omega * t_in_step)

    # DCM tracking controller
    cop = xi_ref - (1/omega) * omega * (xi_ref - r)

    # LIPM dynamics
    xddot = omega**2 * (x - cop)
    xdot += xddot * dt
    x += xdot * dt

    if k % 60 == 0:
        print(f"{t:5.2f}    {x:7.4f}  {xi:7.4f}   {cop:7.4f}")
`}
/>

## ZMPベース手法に対する利点

1. **直感的**: 「どこに踏み出すか」に直接答える
2. **押し回復**: 外乱対応に自然に拡張可能
3. **一次ダイナミクス**: DCMは二次の重心ダイナミクスより制御が容易
4. **逆方向計画**: 最終ステップでの停止を保証

## 参考文献

- J. Pratt et al., "[Capture Point: A Step toward Humanoid Push Recovery](https://doi.org/10.1109/ICHR.2006.321385)," *Proc. IEEE-RAS Humanoids*, 2006.
- J. Englsberger et al., "[Three-Dimensional Bipedal Walking Control Based on Divergent Component of Motion](https://doi.org/10.1109/TRO.2015.2405592)," *IEEE Trans. Robotics*, 2015.
- T. Koolen et al., "[Capturability-based analysis and control of legged locomotion](https://doi.org/10.1177/0278364912452673)," *Int. J. Robotics Research*, 2012.

<InteractiveDemo title="Push Recovery Simulation">
  <p className="text-sm text-gray-500">
    Interactive push recovery simulation with capture point visualization coming soon.
  </p>
</InteractiveDemo>
