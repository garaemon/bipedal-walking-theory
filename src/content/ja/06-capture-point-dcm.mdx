import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { CapturePointDiagram, DCMWalkingDiagram } from "@/components/diagrams/CapturePointDiagram";
import { DCMPhaseDiagram } from "@/components/diagrams/DCMPhaseDiagram";

# キャプチャポイントとDCM

キャプチャポイント（発散運動成分とも呼ばれる）は、二足歩行のバランスを理解し、押し回復戦略を設計するための直感的なフレームワークを提供します。これは根本的な問いに答えます: *ロボットが転倒を避けるためにはどこに足を踏み出すべきか？*

## キャプチャポイントの定義

**キャプチャポイント** $\boldsymbol{\xi}$ は、ロボットが瞬時に足を置くことで完全に停止できる地面上の点です。

<MathBlock tex="\boldsymbol{\xi} = \mathbf{x} + \frac{1}{\omega}\dot{\mathbf{x}}" />

ここで $\mathbf{x}$ は重心位置、$\dot{\mathbf{x}}$ は重心速度、$\omega = \sqrt{g/z_c}$ はLIPMの固有周波数です。

<CapturePointDiagram />

### 直感的理解

- ロボットが $\boldsymbol{\xi}$ の位置に正確に足を置くと、重心は減速して足の真上で停止します
- キャプチャポイントは常に重心の**前方**（運動方向）にあります
- 速度が大きいほど $\boldsymbol{\xi}$ はさらに前方に移動します

## 発散運動成分 (DCM)

DCMはキャプチャポイントと数学的に同一です。この名称は、LIPMのダイナミクスを**安定**成分と**不安定**成分に分解することに由来します。

LIPMの方程式 $\ddot{x} = \omega^2(x - r)$（$r$ はCoPとする）から出発します。これは二次系です。分解するために、新しい座標を定義します:

$$
\xi = x + \frac{\dot{x}}{\omega} \quad \text{(DCM / unstable component)}
$$

$$
\zeta = x - \frac{\dot{x}}{\omega} \quad \text{(stable component)}
$$

$x = \frac{1}{2}(\xi + \zeta)$ かつ $\dot{x} = \frac{\omega}{2}(\xi - \zeta)$ であるため、これは可逆な座標変換です。

### DCMダイナミクス

$\xi = x + \dot{x}/\omega$ を微分し、$\ddot{x} = \omega^2(x - r)$ を代入すると:

$$
\dot{\xi} = \dot{x} + \frac{\ddot{x}}{\omega} = \dot{x} + \omega(x - r) = \omega\left(x + \frac{\dot{x}}{\omega} - r\right) = \omega(\xi - r)
$$

同様に $\dot{\zeta} = -\omega(\zeta - r)$ が得られます。二次のLIPMが二つの**独立な**一次系に分解されました:
- $\dot{\xi} = +\omega(\xi - r)$: **不安定**（$r$ から発散する）
- $\dot{\zeta} = -\omega(\zeta - r)$: **安定**（$r$ に収束する）

安定成分 $\zeta$ は自然に収束するので、制御器は不安定なDCM $\xi$ のみを管理すればよいのです。これがDCMベースの制御が効果的な理由です。

<DCMPhaseDiagram />

CoP $r$ がDCMの制御入力として機能します。

### DCMによる重心ダイナミクス

重心は一次安定ダイナミクスでDCMに追従します:

$$
\dot{x} = -\omega(x - \xi)
$$

これは重心が常にDCMに収束することを意味し、制御設計にとって強力な性質です。

## 押し回復

押されると、ロボットのDCMがシフトします。回復戦略は以下の通りです:

1. **足首戦略**: 足の中でCoPを調整してDCMを誘導
2. **踏み出し戦略**: 新しいキャプチャポイントに足を置く
3. **腰戦略**: 角運動量を利用してDCMをシフト

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Push recovery using capture point
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)

# Initial state (standing still)
x = 0.0
xdot = 0.0

xi = x + xdot / omega
print("=== Before Push ===")
print(f"CoM: {x:.3f} m, Vel: {xdot:.3f} m/s")
print(f"Capture Point: {xi:.3f} m")
print()

# Apply a push (impulse changes velocity)
push_impulse = 0.3  # m/s velocity change
xdot += push_impulse

xi = x + xdot / omega
print("=== After Push ===")
print(f"CoM: {x:.3f} m, Vel: {xdot:.3f} m/s")
print(f"Capture Point: {xi:.4f} m")
print()

foot_half_length = 0.12
if abs(xi) <= foot_half_length:
    print("Ankle strategy sufficient!")
    print(f"  Move CoP to {xi:.4f} m")
else:
    print("Need stepping strategy!")
    print(f"  Capture point {xi:.4f} m outside foot")
    print(f"  Must step to {xi:.4f} m to recover")
print()

# Simulate recovery by stepping to capture point
r = xi
dt = 0.01
n_sim = 100

time_arr = []
com_arr = []
dcm_arr = []
cp_arr = []

print("=== Recovery Simulation ===")
print("Time(s)  CoM(m)   Vel(m/s)  DCM(m)")
print("-" * 42)

for i in range(n_sim):
    t = i * dt
    xi_dot = omega * (xi - r)
    xi += xi_dot * dt
    xdot = -omega * (x - xi)
    x += xdot * dt

    time_arr.append(t)
    com_arr.append(x)
    dcm_arr.append(xi)
    cp_arr.append(x + xdot / omega)

    if i % 10 == 0:
        print(f"{t:5.2f}    {x:7.4f}  {xdot:7.4f}   {xi:7.4f}")

# Plot recovery trajectory
fig, ax = plt.subplots(figsize=(7, 4))
ax.plot(time_arr, com_arr, 'b-', linewidth=2, label='CoM')
ax.plot(time_arr, dcm_arr, 'r--', linewidth=2, label='DCM')
ax.plot(time_arr, cp_arr, 'g:', linewidth=1.5, label='Capture Pt')
ax.axhline(y=r, color='orange', linestyle='-.',
           linewidth=1, label='Foot (CoP)')
ax.axhline(y=foot_half_length, color='gray',
           linestyle=':', linewidth=0.8, label='Foot boundary')
ax.axhline(y=-foot_half_length, color='gray',
           linestyle=':', linewidth=0.8)
ax.set_xlabel('Time (s)')
ax.set_ylabel('Position (m)')
ax.set_title('Push Recovery: CoM, DCM, and Capture Point')
ax.legend(fontsize=8)
ax.grid(True, alpha=0.3)

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

