import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { TaskPriorityDiagram } from "@/components/diagrams/WholeBodyControlDiagram";
import { NullSpaceDiagram } from "@/components/diagrams/NullSpaceDiagram";

# 全身運動制御

歩行ロボットは、バランスの維持、足の配置、姿勢の制御、関節限界の回避など、複数の目標を同時に達成するために協調させなければならない多くの自由度を持っています。

## 順運動学

関節角度 $\mathbf{q} \in \mathbb{R}^n$ が与えられたとき、順運動学写像はエンドエフェクタ（例: 足）の位置と姿勢を計算します:

$$
\mathbf{x} = f(\mathbf{q})
$$

ここで $\mathbf{x} \in \mathbb{R}^m$ はタスク空間の位置です（$m \leq n$）。

## ヤコビアン

**ヤコビアン** $\mathbf{J}$ は関節速度をタスク空間速度に関連付けます:

$$
\dot{\mathbf{x}} = \mathbf{J}(\mathbf{q})\dot{\mathbf{q}}
$$

ここで $\mathbf{J} = \frac{\partial f}{\partial \mathbf{q}} \in \mathbb{R}^{m \times n}$ です。

**例: 2リンク平面アーム。** リンク長 $l_1, l_2$、関節角度 $q_1, q_2$ の2リンクアームの場合、順運動学は $x = l_1 \cos q_1 + l_2 \cos(q_1 + q_2)$, $y = l_1 \sin q_1 + l_2 \sin(q_1 + q_2)$ です。各出力を各関節角度で微分すると:

$$
\mathbf{J} = \begin{bmatrix}
-l_1 \sin q_1 - l_2 \sin(q_1+q_2) & -l_2 \sin(q_1+q_2) \\
l_1 \cos q_1 + l_2 \cos(q_1+q_2) & l_2 \cos(q_1+q_2)
\end{bmatrix}
$$

各列は一つの関節速度がエンドエフェクタ速度にどう寄与するかを示します。ヒューマノイドロボットでは、ヤコビアンは関節速度を重心速度、足速度、手速度などに写像します。

## 逆運動学

所望のタスク空間速度 $\dot{\mathbf{x}}_{des}$ が与えられたとき、関節速度を求めます:

$$
\dot{\mathbf{q}} = \mathbf{J}^{\dagger}\dot{\mathbf{x}}_{des}
$$

ここで $\mathbf{J}^{\dagger}$ は**ムーア・ペンローズ擬似逆行列**です。「太い」行列（$n > m$, 関節がタスク次元より多い場合）では:

$$
\mathbf{J}^{\dagger} = \mathbf{J}^T(\mathbf{J}\mathbf{J}^T)^{-1}
$$

擬似逆行列は所望のタスク空間速度を達成する**最小ノルム**の関節速度を与えます。$n = m$ かつ $\mathbf{J}$ が正則な場合は $\mathbf{J}^{\dagger} = \mathbf{J}^{-1}$ です。

### 特異点の取り扱い

**特異点**では $\mathbf{J}$ がランク落ちします（例: 2リンクアームが完全に伸びた状態）。特異点近傍では擬似逆行列が極めて大きな関節速度を生成します。**減衰最小二乗法** (DLS) はこれに対処します:

$$
\mathbf{J}^{\dagger}_{DLS} = \mathbf{J}^T(\mathbf{J}\mathbf{J}^T + \lambda^2 \mathbf{I})^{-1}
$$

減衰係数 $\lambda > 0$ は追従精度と特異姿勢近傍での関節速度の有界性のトレードオフを制御します。

ロボットがタスク次元より多くの関節を持つ場合（$n > m$）、システムは**冗長**であり、擬似逆行列は一つの特定の解を与えます。残りの自由度は零空間を通じて利用されます。

### 零空間

$\mathbf{J}$ の零空間は、タスク空間出力に影響を与えない運動を表します。幾何学的には、零空間とは $\mathbf{J}\dot{\mathbf{q}} = \mathbf{0}$ となるすべての関節速度方向の集合です。ロボットはタスク空間出力を変えずに内部的に動くことができます。

行列 $\mathbf{N} = \mathbf{I} - \mathbf{J}^{\dagger}\mathbf{J}$ は零空間への**射影子**です。
任意の関節速度 $\dot{\mathbf{q}}_0$ に対して $\mathbf{J}(\mathbf{N}\dot{\mathbf{q}}_0) = (\mathbf{J} - \mathbf{J}\mathbf{J}^{\dagger}\mathbf{J})\dot{\mathbf{q}}_0 = \mathbf{0}$ となります
（$\mathbf{J}\mathbf{J}^{\dagger}\mathbf{J} = \mathbf{J}$ は擬似逆行列の性質）。
射影された成分 $\mathbf{N}\dot{\mathbf{q}}_0$ は完全に零空間に含まれ、主タスクに影響を与えません。

この零空間を用いて副次的な目標を追加できます:

$$
\dot{\mathbf{q}} = \mathbf{J}^{\dagger}\dot{\mathbf{x}}_{des} + (\mathbf{I} - \mathbf{J}^{\dagger}\mathbf{J})\dot{\mathbf{q}}_0
$$

ここで $\dot{\mathbf{q}}_0$ は副次タスクのための任意の関節速度です。

<NullSpaceDiagram />

## タスク優先度フレームワーク

<TaskPriorityDiagram />

ヒューマノイドロボットでは、複数のタスクが優先度順に編成されます:

$$
\dot{\mathbf{q}} = \dot{\mathbf{q}}_1 + N_1(\dot{\mathbf{q}}_2 + N_2(\dot{\mathbf{q}}_3 + \cdots))
$$

ここで $\dot{\mathbf{q}}_i = \mathbf{J}_i^{\dagger}(\dot{\mathbf{x}}_i - \mathbf{J}_i \dot{\mathbf{q}}_{i-1})$、$N_i = \mathbf{I} - \mathbf{J}_i^{\dagger}\mathbf{J}_i$ は零空間射影子です。

高優先度のタスクは確実に達成され、低優先度のタスクは残りの自由度のみを使用します。

<CodeEditor
  initialCode={`import math

# 2-link planar robot IK demonstration
# (simplified whole-body control example)

l1 = 0.4  # link 1 length (m)
l2 = 0.35  # link 2 length (m)

def forward_kinematics(q1, q2):
    """Compute end-effector position from joint angles."""
    x = l1 * math.cos(q1) + l2 * math.cos(q1 + q2)
    y = l1 * math.sin(q1) + l2 * math.sin(q1 + q2)
    return x, y

def compute_jacobian(q1, q2):
    """Compute 2x2 Jacobian."""
    J11 = -l1 * math.sin(q1) - l2 * math.sin(q1 + q2)
    J12 = -l2 * math.sin(q1 + q2)
    J21 = l1 * math.cos(q1) + l2 * math.cos(q1 + q2)
    J22 = l2 * math.cos(q1 + q2)
    return J11, J12, J21, J22

def compute_link_positions(q1, q2):
    """Return base, elbow, and end-effector positions."""
    elbow_x = l1 * math.cos(q1)
    elbow_y = l1 * math.sin(q1)
    ee_x = elbow_x + l2 * math.cos(q1 + q2)
    ee_y = elbow_y + l2 * math.sin(q1 + q2)
    return (0, 0), (elbow_x, elbow_y), (ee_x, ee_y)

# Start configuration
q1, q2 = math.pi/4, -math.pi/6
x, y = forward_kinematics(q1, q2)
print("=== 2-Link Robot Inverse Kinematics ===")
init_q1_deg = math.degrees(q1)
init_q2_deg = math.degrees(q2)
print(f"Initial config: q1={init_q1_deg:.1f} deg, q2={init_q2_deg:.1f} deg")
print(f"End-effector: ({x:.4f}, {y:.4f}) m")
print()

# Target position
x_target, y_target = 0.5, 0.3
print(f"Target: ({x_target:.3f}, {y_target:.3f}) m")
print()

# IK using Jacobian pseudoinverse (iterative)
dt = 0.05
gain = 2.0
print("Iter  q1(deg)  q2(deg)  x(m)     y(m)     err(mm)")
print("-" * 55)

# Store intermediate poses for visualization
pose_history = []

for i in range(20):
    x, y = forward_kinematics(q1, q2)
    ex, ey = x_target - x, y_target - y
    error = math.sqrt(ex**2 + ey**2)
    pose_history.append((q1, q2))

    if i % 2 == 0:
        q1_deg = math.degrees(q1)
        q2_deg = math.degrees(q2)
        err_mm = error * 1000
        print(f" {i:2d}   {q1_deg:7.2f}  {q2_deg:7.2f}  "
              f"{x:7.4f}  {y:7.4f}  {err_mm:7.3f}")

    if error < 0.001:
        print(f"\\nConverged in {i} iterations!")
        break

    # Jacobian pseudoinverse (2x2 case = inverse)
    J11, J12, J21, J22 = compute_jacobian(q1, q2)
    det = J11 * J22 - J12 * J21

    if abs(det) < 1e-6:
        print("Near singularity!")
        break

    # Inverse of 2x2 Jacobian
    dq1 = (J22 * ex - J12 * ey) / det * gain * dt
    dq2 = (-J21 * ex + J11 * ey) / det * gain * dt

    q1 += dq1
    q2 += dq2

# Visualization of the IK convergence
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

fig, ax = plt.subplots(1, 1, figsize=(8, 6))

# Draw intermediate poses with fading opacity
num_poses = len(pose_history)
for idx, (pq1, pq2) in enumerate(pose_history):
    fade = 0.1 + 0.3 * (idx / max(num_poses - 1, 1))
    base, elbow, ee = compute_link_positions(pq1, pq2)
    xs = [base[0], elbow[0], ee[0]]
    ys = [base[1], elbow[1], ee[1]]
    ax.plot(xs, ys, 'o-', color='steelblue', alpha=fade,
            linewidth=1.5, markersize=4)

# Draw final pose with bold lines
final_q1, final_q2 = pose_history[-1]
base, elbow, ee = compute_link_positions(final_q1, final_q2)
xs = [base[0], elbow[0], ee[0]]
ys = [base[1], elbow[1], ee[1]]
ax.plot(xs, ys, 'o-', color='darkblue', linewidth=3.5,
        markersize=8, label='Final pose', zorder=5)

# Draw initial pose
init_q1, init_q2 = pose_history[0]
b0, e0, ee0 = compute_link_positions(init_q1, init_q2)
xs0 = [b0[0], e0[0], ee0[0]]
ys0 = [b0[1], e0[1], ee0[1]]
ax.plot(xs0, ys0, 'o--', color='gray', linewidth=2,
        markersize=6, label='Initial pose', zorder=4)

# Draw target
ax.plot(x_target, y_target, 'r*', markersize=18,
        label='Target', zorder=6)

# Mark base joint
ax.plot(0, 0, 'ks', markersize=10, zorder=7)

ax.set_xlabel('x (m)')
ax.set_ylabel('y (m)')
ax.set_title('2-Link Robot Arm: IK Convergence')
ax.set_aspect('equal')
ax.legend(loc='upper left')
ax.grid(True, alpha=0.3)
ax.set_xlim(-0.2, 0.9)
ax.set_ylim(-0.2, 0.8)

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## シミュレーション: 可操作度楕円体

**可操作度楕円体**は、与えられたアーム姿勢でエンドエフェクタがどの方向に動きやすいかを視覚化します。
ヤコビアンの特異値分解 $\mathbf{J} = \mathbf{U}\boldsymbol{\Sigma}\mathbf{V}^T$ から主軸（$\mathbf{U}$ の列）とその大きさ（特異値 $\sigma_i$）が得られます。
楕円体の半軸は $\sigma_i \mathbf{u}_i$ です。
吉川の**可操作度** $w = \sigma_1 \sigma_2 \cdots \sigma_m = \sqrt{\det(\mathbf{J}\mathbf{J}^T)}$ は全体的な器用さを定量化します:
特異点で $w = 0$、最も器用な姿勢で最大となります。

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

l1 = 0.4  # link 1 length
l2 = 0.35  # link 2 length

def compute_link_positions(q1, q2):
    """Return base, elbow, and end-effector positions."""
    elbow_x = l1 * math.cos(q1)
    elbow_y = l1 * math.sin(q1)
    ee_x = elbow_x + l2 * math.cos(q1 + q2)
    ee_y = elbow_y + l2 * math.sin(q1 + q2)
    return (0, 0), (elbow_x, elbow_y), (ee_x, ee_y)

def compute_jacobian_matrix(q1, q2):
    """Compute the 2x2 Jacobian as a numpy array."""
    s1 = math.sin(q1)
    s12 = math.sin(q1 + q2)
    c1 = math.cos(q1)
    c12 = math.cos(q1 + q2)
    J = np.array([
        [-l1*s1 - l2*s12, -l2*s12],
        [ l1*c1 + l2*c12,  l2*c12]
    ])
    return J

def compute_ellipse_points(center, U, sigmas, n_pts=100):
    """Compute points on the manipulability ellipse."""
    theta = np.linspace(0, 2*np.pi, n_pts)
    circle = np.array([np.cos(theta), np.sin(theta)])
    scale = np.diag(sigmas)
    ellipse = U @ scale @ circle
    ellipse[0] += center[0]
    ellipse[1] += center[1]
    return ellipse

# Define 4 different arm configurations
configs = [
    (math.pi/6, -math.pi/3, "q1=30, q2=-60"),
    (math.pi/3, -math.pi/6, "q1=60, q2=-30"),
    (math.pi/4, math.pi/4, "q1=45, q2=45"),
    (math.pi/2, -math.pi/2, "q1=90, q2=-90"),
]

fig, axes = plt.subplots(2, 2, figsize=(10, 10))
ellipse_scale = 0.15

print("=== Manipulability Ellipsoid Analysis ===")
print()

for idx, (q1, q2, label) in enumerate(configs):
    row = idx // 2
    col = idx % 2
    ax = axes[row][col]
    base, elbow, ee = compute_link_positions(q1, q2)

    # Draw the arm
    arm_x = [base[0], elbow[0], ee[0]]
    arm_y = [base[1], elbow[1], ee[1]]
    ax.plot(arm_x, arm_y, 'o-', color='darkblue',
            linewidth=3, markersize=8, zorder=5)
    ax.plot(0, 0, 'ks', markersize=10, zorder=6)

    # Compute Jacobian and SVD
    J = compute_jacobian_matrix(q1, q2)
    U_mat, sigma_vec, Vt = np.linalg.svd(J)
    w = sigma_vec[0] * sigma_vec[1]

    # Draw manipulability ellipse at end-effector
    scaled_sigmas = sigma_vec * ellipse_scale
    ellipse_pts = compute_ellipse_points(
        np.array([ee[0], ee[1]]),
        U_mat, scaled_sigmas
    )
    ax.fill(ellipse_pts[0], ellipse_pts[1],
            alpha=0.3, color='coral')
    ax.plot(ellipse_pts[0], ellipse_pts[1],
            color='red', linewidth=2)

    # Draw principal axes as arrows
    for k in range(2):
        d = U_mat[:, k] * sigma_vec[k] * ellipse_scale
        ax.annotate(
            '', xy=(ee[0]+d[0], ee[1]+d[1]),
            xytext=(ee[0], ee[1]),
            arrowprops=dict(
                arrowstyle='->', color='green', lw=2
            ))

    title_str = label + "\\nw=" + f"{w:.4f}"
    ax.set_title(title_str, fontsize=11)
    ax.set_aspect('equal')
    ax.grid(True, alpha=0.3)
    ax.set_xlim(-0.3, 0.9)
    ax.set_ylim(-0.4, 0.9)
    ax.set_xlabel('x (m)')
    ax.set_ylabel('y (m)')

    s1_val = sigma_vec[0]
    s2_val = sigma_vec[1]
    cond = s1_val / max(s2_val, 1e-10)
    print(f"Config: {label}")
    print(f"  Singular values: s1={s1_val:.4f}, s2={s2_val:.4f}")
    print(f"  Manipulability w = {w:.4f}")
    print(f"  Condition number = {cond:.2f}")
    print()

fig.suptitle('Manipulability Ellipsoids for 2-Link Arm',
             fontsize=14, fontweight='bold')
plt.tight_layout()

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## マルチタスク制御のための二次計画法

現代の全身コントローラは問題を**QP**として定式化します:

$$
\min_{\dot{\mathbf{q}}} \sum_{i} w_i \|\mathbf{J}_i\dot{\mathbf{q}} - \dot{\mathbf{x}}_{i,des}\|^2
$$

制約条件:
- 関節位置制限: $\mathbf{q}_{min} \leq \mathbf{q} + \dot{\mathbf{q}}dt \leq \mathbf{q}_{max}$
- 関節速度制限: $|\dot{\mathbf{q}}| \leq \dot{\mathbf{q}}_{max}$
- トルク制限: $|\boldsymbol{\tau}| \leq \boldsymbol{\tau}_{max}$

このアプローチは、零空間法では扱えない不等式制約を処理できます。

## 操作空間制御

Khatibの操作空間定式化はタスク空間での力制御を可能にします:

$$
\mathbf{F} = \Lambda(\mathbf{q})\ddot{\mathbf{x}}_{des} + \boldsymbol{\mu}(\mathbf{q}, \dot{\mathbf{q}}) + \mathbf{p}(\mathbf{q})
$$

ここで $\Lambda = (J M^{-1} J^T)^{-1}$ は操作空間慣性行列、$\boldsymbol{\mu}$ はコリオリ/遠心力項、$\mathbf{p}$ は重力です。

対応する関節トルクは:

$$
\boldsymbol{\tau} = \mathbf{J}^T \mathbf{F} + (\mathbf{I} - \mathbf{J}^T \bar{\mathbf{J}}^T)\boldsymbol{\tau}_0
$$

## 参考文献

- O. Khatib, "[A Unified Approach for Motion and Force Control of Robot Manipulators: The Operational Space Formulation](https://khatib.stanford.edu/publications/pdfs/Khatib_1987_RA.pdf)," *IEEE J. Robotics and Automation*, 1987.
- L. Sentis and O. Khatib, "[Synthesis of Whole-Body Behaviors through Hierarchical Control of Behavioral Primitives](https://khatib.stanford.edu/publications/pdfs/Sentis_2005_IJHR.pdf)," *Int. J. Humanoid Robotics*, 2005.

<InteractiveDemo title="Robot Arm IK Demo">
  <p className="text-sm text-gray-500">
    Interactive robot arm IK with task priority visualization coming soon.
  </p>
</InteractiveDemo>
