import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { CPGNetworkDiagram } from "@/components/diagrams/CPGDiagram";
import { HopfOscillatorDiagram } from "@/components/diagrams/HopfOscillatorDiagram";

# セントラルパターンジェネレータ (CPG)

セントラルパターンジェネレータは、脊椎動物の脊髄に存在する神経回路で、リズミックな感覚入力を必要とせずにリズミックな運動パターンを生成します。CPGベースのコントローラは、ロコモーションへの生物学的に着想を得たアプローチを提供します。

## 生物学的背景

動物において、脊髄のCPGは歩行、遊泳、飛行の基本的なリズミックパターンを生成します。主な特性:

- **自律リズム**: 外部タイミングなしに振動を生成
- **感覚変調**: フィードバックが周波数、振幅、位相を調整
- **頑健性**: 外乱に対しても機能を継続

## 結合振動子モデル

CPGネットワークは、特定の位相関係で結合された振動子で構成されます。CPGネットワークの位相モデルは以下の通りです:

<MathBlock tex="\dot{\phi}_i = \omega_i + \sum_{j} w_{ij} \sin(\phi_j - \phi_i - \psi_{ij})" />

ここで:
- $\phi_i$ は振動子 $i$ の位相
- $\omega_i$ は固有周波数
- $w_{ij}$ は振動子 $j$ から $i$ への結合重み
- $\psi_{ij}$ は目標位相差

<CPGNetworkDiagram />

### 結合振動子が収束する理由

この結合則がなぜ振動子を目標の位相関係に強制するのかは、直感的には明らかではありません。理解するために、振動子 $i$ と $j$ の間の位相誤差を以下のように定義します:

$$
e_{ij} = \phi_j - \phi_i - \psi_{ij}
$$

振動子が目標の関係で同期しているとき、$e_{ij} = 0$ となります。この同期状態の近傍では、結合項 $w_{ij}\sin(e_{ij})$ は**復元力**のように作用します。$e_{ij}$ が小さい正の値（位相差が目標より大きい）の場合、$\sin(e_{ij}) > 0$ が振動子 $i$ を前に引っ張り、差を縮めます。$e_{ij}$ が負の場合は力が逆転します。

安定性をより厳密に解析するために、$e_{ij}=0$ の近傍で $\sin(e_{ij}) \approx e_{ij}$ と線形化します。誤差のダイナミクスは以下のようになります:

$$
\dot{e}_{ij} \approx -(w_{ij} + w_{ji})\, e_{ij}
$$

結合重みが正である限り、これは指数関数的に収束する安定な1次系です。結合は、振動子を正しい位相関係に「ロック」するバネ（剛性 $w_{ij} + w_{ji}$）と全く同じように作用します。結合重みが大きいほど収束は速くなりますが、系が硬くなり適応性が低下する可能性があります。

## 歩行のための位相協調

二足歩行における主な位相関係は以下の通りです:

| 関節ペア | 位相オフセット | 意味 |
|-----------|-------------|---------|
| 左股関節 - 右股関節 | $\pi$ | 交互の脚運動 |
| 股関節 - 膝（同側） | $\pi/2$ | 膝が股関節に対して四分の一周期先行 |
| 左膝 - 右膝 | $\pi$ | 逆位相 |

## 振幅制御CPG

振幅制御を含むより完全なCPGモデルは、ホップ振動子を使用します:

$$
\dot{x}_i = \alpha(\mu_i - r_i^2)x_i - \omega_i y_i
$$

$$
\dot{y}_i = \alpha(\mu_i - r_i^2)y_i + \omega_i x_i
$$

ここで $r_i = \sqrt{x_i^2 + y_i^2}$、$\mu_i$ は振幅を制御し、$\alpha$ はリミットサイクルへの収束速度を制御します。

### ホップ振動子の直感的理解

上記の方程式は、**極座標** $(r, \theta)$（$x = r\cos\theta$、$y = r\sin\theta$）で表すとはるかに明確になります:

$$
\dot{r} = \alpha(\mu - r^2)\,r, \quad \dot{\theta} = \omega
$$

角度の方程式 $\dot{\theta} = \omega$ は、振動子が一定の周波数で回転することを意味します。重要な挙動は半径方向の方程式にあります。$\dot{r} = 0$ として平衡点を求めると:

- $r = 0$ は平衡点ですが、**不安定**です。$r$ がわずかに正で $\mu > 0$ の場合、$\mu - r^2 > 0$ なので $\dot{r} > 0$ となり、$r$ は成長します。
- $r = \sqrt{\mu}$ は**安定な平衡点**です。$r < \sqrt{\mu}$ の場合 $\dot{r} > 0$（振幅が成長）、$r > \sqrt{\mu}$ の場合 $\dot{r} < 0$（振幅が減衰）となります。

これは、初期条件に関わらず振幅が $\sqrt{\mu}$ に**自己調整**されることを意味します。これが**リミットサイクル**の定義的性質であり、近傍の全ての軌道を引き寄せます。パラメータ $\alpha$ は、この収束がどれだけ速く起こるかを制御します。

<HopfOscillatorDiagram />

## Simulation: Hopf Oscillator Dynamics

以下のシミュレーションは、異なる初期条件からHopf振動子がリミットサイクルに収束する様子を示します。左パネルはx-y位相面での軌道が半径 $\sqrt{\mu}$ の円に収束する様子、右パネルは振幅 $r(t)$ の時間発展を示します。

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Hopf oscillator parameters
mu = 1.0       # amplitude parameter -> limit cycle at r = sqrt(mu) = 1.0
alpha = 5.0    # convergence rate
omega = 2 * math.pi * 1.0  # oscillation frequency (1 Hz)

# Different initial radii to show convergence
initial_radii = [0.1, 0.5, 1.0, 1.5, 2.0]
dt = 0.002
sim_time = 3.0
num_steps = int(sim_time / dt)

print("=== Hopf Oscillator Simulation ===")
print(f"mu = {mu}, alpha = {alpha}, omega = {omega/(2*math.pi):.1f} Hz")
print(f"Limit cycle radius: r* = sqrt(mu) = {math.sqrt(mu):.2f}")
print()

def simulate_hopf(r0, mu_val, alpha_val, omega_val, dt_val, n_steps):
    """Simulate Hopf oscillator from initial radius r0."""
    x = r0
    y = 0.0
    xs, ys, rs, ts = [x], [y], [r0], [0.0]
    for k in range(1, n_steps):
        r_sq = x * x + y * y
        dx = alpha_val * (mu_val - r_sq) * x - omega_val * y
        dy = alpha_val * (mu_val - r_sq) * y + omega_val * x
        x += dx * dt_val
        y += dy * dt_val
        xs.append(x)
        ys.append(y)
        rs.append(math.sqrt(x * x + y * y))
        ts.append(k * dt_val)
    return xs, ys, rs, ts

# Run simulations and print summary
trajectories = {}
for r0 in initial_radii:
    xs, ys, rs, ts = simulate_hopf(r0, mu, alpha, omega, dt, num_steps)
    trajectories[r0] = (xs, ys, rs, ts)
    print(f"r0 = {r0:.1f} -> final r = {rs[-1]:.4f}")

print()
print("All trajectories converge to r = 1.0 (the limit cycle)")

def plot_hopf_phase_plane(traj_data, mu_val):
    """Plot Hopf oscillator phase plane and r(t) time series."""
    fig, axes = plt.subplots(1, 2, figsize=(11, 5))
    colors = ["#2563eb", "#16a34a", "#ea580c", "#dc2626", "#7c3aed"]
    r_star = np.sqrt(mu_val)

    ax_phase = axes[0]
    theta_circle = np.linspace(0, 2 * np.pi, 200)
    ax_phase.plot(
        r_star * np.cos(theta_circle),
        r_star * np.sin(theta_circle),
        "k--", linewidth=1.5, alpha=0.5,
        label=f"Limit cycle (r={r_star:.1f})"
    )
    for idx, (r0, (xs, ys, rs, ts)) in enumerate(traj_data.items()):
        ax_phase.plot(xs, ys, color=colors[idx], linewidth=0.8,
                      alpha=0.8, label=f"r0 = {r0:.1f}")
        ax_phase.plot(xs[0], ys[0], "o", color=colors[idx],
                      markersize=6)
    ax_phase.set_xlabel("x")
    ax_phase.set_ylabel("y")
    ax_phase.set_title("Phase Plane (x-y)", fontweight="bold")
    ax_phase.set_aspect("equal")
    ax_phase.legend(fontsize=7, loc="upper right")
    ax_phase.grid(True, alpha=0.3)
    ax_phase.set_xlim(-2.3, 2.3)
    ax_phase.set_ylim(-2.3, 2.3)

    ax_r = axes[1]
    ax_r.axhline(y=r_star, color="k", linestyle="--",
                 linewidth=1.5, alpha=0.5, label=f"r* = {r_star:.1f}")
    for idx, (r0, (xs, ys, rs, ts)) in enumerate(traj_data.items()):
        ax_r.plot(ts, rs, color=colors[idx], linewidth=1.3,
                  label=f"r0 = {r0:.1f}")
    ax_r.set_xlabel("Time (s)")
    ax_r.set_ylabel("r(t)")
    ax_r.set_title("Amplitude Convergence", fontweight="bold")
    ax_r.legend(fontsize=8)
    ax_r.grid(True, alpha=0.3)

    fig.suptitle(
        "Hopf Oscillator: Convergence to Limit Cycle",
        fontsize=13, fontweight="bold"
    )
    fig.tight_layout()
    return fig

buf = io.BytesIO()
fig = plot_hopf_phase_plane(trajectories, mu)
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close(fig)
`}
/>

<CodeEditor
  initialCode={`import math

# CPG simulation using coupled phase oscillators
# For bipedal walking with 4 oscillators

# Parameters
omega_base = 2 * math.pi * 1.5  # base frequency (1.5 Hz walking)
coupling_strength = 5.0

# Phase offsets (desired relationships)
# 0: left hip, 1: right hip, 2: left knee, 3: right knee
psi = [
    [0, math.pi, math.pi/2, 0],       # from left hip's perspective
    [math.pi, 0, 0, math.pi/2],       # from right hip's perspective
    [-math.pi/2, 0, 0, math.pi],      # from left knee's perspective
    [0, -math.pi/2, math.pi, 0],      # from right knee's perspective
]

# Coupling weights (symmetric network)
w = [
    [0, 3, 2, 0],
    [3, 0, 0, 2],
    [2, 0, 0, 1],
    [0, 2, 1, 0],
]

# Initial phases (random start)
phi = [0.0, 0.5, 1.0, 2.0]

dt = 0.001
sim_time = 3.0
steps = int(sim_time / dt)

# Record history for plotting
record_interval = 10
time_history = []
angle_history = [[], [], [], []]
phase_diff_history = []

print("=== CPG Simulation ===")
print(f"Walking frequency: {omega_base/(2*math.pi):.1f} Hz")
print()
print("Time(s)  L_Hip    R_Hip    L_Knee   R_Knee   Phase_diff(L-R hip)")
print("-" * 65)

for k in range(steps):
    t = k * dt

    # Compute phase derivatives
    dphi = [0.0] * 4
    for i in range(4):
        dphi[i] = omega_base
        for j in range(4):
            dphi[i] += w[i][j] * math.sin(phi[j] - phi[i] - psi[i][j])

    # Update phases
    for i in range(4):
        phi[i] += dphi[i] * dt

    # Record data for plotting
    if k % record_interval == 0:
        time_history.append(t)
        for i in range(4):
            angle_history[i].append(math.sin(phi[i]))
        pd = (phi[1] - phi[0]) % (2 * math.pi)
        if pd > math.pi:
            pd -= 2 * math.pi
        phase_diff_history.append(pd)

    # Print joint angles (sine of phase as proxy)
    if k % 300 == 0:
        angles = [math.sin(phi[i]) for i in range(4)]
        phase_diff = (phi[1] - phi[0]) % (2 * math.pi)
        if phase_diff > math.pi:
            phase_diff -= 2 * math.pi
        print(f"{t:5.2f}    {angles[0]:+6.3f}  {angles[1]:+6.3f}  "
              f"{angles[2]:+6.3f}  {angles[3]:+6.3f}   "
              f"{phase_diff:.3f} ({phase_diff/math.pi:.2f}pi)")

print()
print("Phase difference should converge to pi (anti-phase)")

# --- Plot joint angles and phase convergence ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def plot_cpg_results(time_hist, angle_hist, phase_hist):
    """Plot 4-panel CPG simulation results."""
    fig, axes = plt.subplots(2, 2, figsize=(10, 7))
    labels = ["L_Hip", "R_Hip", "L_Knee", "R_Knee"]
    colors = ["#2563eb", "#dc2626", "#16a34a", "#ea580c"]
    t = np.array(time_hist)

    for idx in range(4):
        ax = axes[idx // 2][idx % 2]
        ax.plot(t, angle_hist[idx], color=colors[idx], linewidth=1.2)
        ax.set_title(labels[idx], fontsize=12, fontweight="bold")
        ax.set_ylabel("sin(phi)")
        ax.set_xlabel("Time (s)")
        ax.set_ylim(-1.3, 1.3)
        ax.grid(True, alpha=0.3)

    fig.suptitle(
        "CPG Joint Angle Trajectories (sin of phase)",
        fontsize=13, fontweight="bold"
    )
    fig.tight_layout()
    return fig

def plot_phase_convergence(time_hist, phase_hist):
    """Plot phase difference convergence to pi."""
    fig, ax = plt.subplots(figsize=(8, 3.5))
    t = np.array(time_hist)
    pd = np.array(phase_hist)
    ax.plot(t, pd / np.pi, color="#7c3aed", linewidth=1.5)
    ax.axhline(y=1.0, color="#dc2626", linestyle="--", alpha=0.7,
               label="Target (pi)")
    ax.set_xlabel("Time (s)")
    ax.set_ylabel("Phase diff (L-R hip) / pi")
    ax.set_title("Phase Difference Convergence", fontweight="bold")
    ax.legend()
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    return fig

def save_and_print_figure(fig):
    """Encode figure as base64 PNG and print for display."""
    buf = io.BytesIO()
    fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
    buf.seek(0)
    img = base64.b64encode(buf.read()).decode("utf-8")
    print(f"data:image/png;base64,{img}")
    plt.close(fig)

save_and_print_figure(plot_cpg_results(
    time_history, angle_history, phase_diff_history
))
save_and_print_figure(plot_phase_convergence(
    time_history, phase_diff_history
))
`}
/>

## CPGパラメータの調整

CPGパラメータを変調することで歩容特性を変化させることができます:

- **周波数 ($\omega$)**: 歩行速度
- **振幅 ($\mu$)**: 歩幅
- **位相オフセット ($\psi$)**: 歩容パターン（ウォーク、トロット、ギャロップ）
- **結合重み ($w$)**: 関節間協調の強さ

<CodeEditor
  initialCode={`import math

# Demonstrate CPG frequency modulation
# Speed changes by adjusting omega

speeds = [
    ("Slow walk", 1.0),
    ("Normal walk", 1.5),
    ("Fast walk", 2.0),
    ("Slow run", 2.5),
]

print("=== CPG Frequency Modulation ===")
print()

dt = 0.001
all_waveforms = {}

for name, freq in speeds:
    omega = 2 * math.pi * freq
    amplitude = 0.3 + 0.15 * freq  # larger steps at higher speed

    # Simulate two cycles for visualization
    sim_duration = 2.0
    num_steps = int(sim_duration / dt)
    max_vel = 0
    times = []
    positions = []

    phi = 0.0
    for k in range(num_steps):
        t = k * dt
        phi += omega * dt
        pos = amplitude * math.sin(phi)
        vel = amplitude * omega * math.cos(phi)
        max_vel = max(max_vel, abs(vel))
        times.append(t)
        positions.append(pos)

    period = 1.0 / freq
    print(f"{name} ({freq:.1f} Hz):")
    print(f"  Period: {period:.3f} s")
    print(f"  Amplitude: {amplitude:.2f} rad")
    print(f"  Max angular velocity: {max_vel:.2f} rad/s")
    print()

    all_waveforms[name] = (times, positions, freq, amplitude)

# --- Plot overlaid waveforms ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def plot_frequency_modulation(waveforms):
    """Plot joint angle waveforms at different walking speeds."""
    fig, axes = plt.subplots(1, 2, figsize=(11, 4.5))
    colors = ["#2563eb", "#16a34a", "#ea580c", "#dc2626"]

    ax_wave = axes[0]
    for idx, (name, (ts, ps, freq, amp)) in enumerate(waveforms.items()):
        ax_wave.plot(ts, ps, color=colors[idx], linewidth=1.3,
                     label=f"{name} ({freq:.1f} Hz)")
    ax_wave.set_xlabel("Time (s)")
    ax_wave.set_ylabel("Joint angle (rad)")
    ax_wave.set_title("Joint Angle Waveforms", fontweight="bold")
    ax_wave.legend(fontsize=8)
    ax_wave.grid(True, alpha=0.3)

    ax_amp = axes[1]
    freqs = [v[2] for v in waveforms.values()]
    amps = [v[3] for v in waveforms.values()]
    ax_amp.bar(
        [f"{f:.1f} Hz" for f in freqs], amps,
        color=colors[:len(freqs)], alpha=0.8
    )
    ax_amp.set_xlabel("Walking frequency")
    ax_amp.set_ylabel("Amplitude (rad)")
    ax_amp.set_title("Amplitude vs Frequency", fontweight="bold")
    ax_amp.grid(True, alpha=0.3, axis="y")

    fig.suptitle(
        "CPG Frequency Modulation",
        fontsize=13, fontweight="bold"
    )
    fig.tight_layout()
    return fig

buf = io.BytesIO()
fig = plot_frequency_modulation(all_waveforms)
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close(fig)
`}
/>

## 感覚フィードバック統合

生物学的CPGの最も重要な特徴の一つは、感覚フィードバックを統合する能力です。純粋なオープンループ振動子として動作するのではなく、実際のCPGは継続的にプロプリオセプティブ入力を受け取り、その挙動を変調します。

**プロプリオセプティブフィードバック**（関節角度、角速度、足部接触力）はCPGパラメータをリアルタイムで変更できます:

- **地面接触センサ**は位相遷移をトリガーします。例えば、足が地面に接触すると、振動子がまだその位相に到達していなくても、CPGは遊脚相から立脚相に即座に切り替えることができます。
- **関節角度フィードバック**は振動子の振幅を調整します。関節が目標角度に達しない場合（障害物など）、過大なトルクを防ぐために振幅パラメータ $\mu$ を減少させることができます。
- **力フィードバック**は立脚期の持続時間を変調します。より大きな地面反力（重い荷物を運ぶ場合など）は立脚相を遅くし、安全に体重を移動するためのより多くの時間を与えます。

これにより、地形や外乱に適応する**閉ループCPG**が作成されます。実用的な例として、足が予想よりも早く地面に接触した場合（例えば、高くなった面に踏み込んだ場合）、地面接触センサがCPGの位相を実際の接触タイミングに合わせて進めます。数学的には、これは加法的な位相補正として実装されます:

$$
\dot{\phi}_i = \omega_i + \sum_j w_{ij}\sin(\phi_j - \phi_i - \psi_{ij}) + F_{\text{feedback}}(\phi_i, s_i)
$$

ここで $s_i$ は感覚信号を表し、$F_{\text{feedback}}$ はセンサ読み取り値を位相補正にマッピングする関数です。

## CPG出力からロボット動作への変換

CPGの出力は通常、関節角度軌道または角速度指令です。しかし、歩行ロボットでは、これらの信号を物理的に意味のある動作にマッピングする必要があります。一般的に2つのアプローチがあります:

**アプローチ1: CPGが足先軌道を生成。** CPG振動子の出力をデカルト空間における目標足先位置として解釈します（例えば、$x$ 成分が前方スイングを制御し、$y$ 成分がリフト高さを制御）。その後、逆運動学が必要な関節角度を計算します。このアプローチは、歩幅と高さの直感的な制御を提供します。

**アプローチ2: CPGが直接関節角度を駆動。** 各振動子の出力を、スケーリングとオフセットパラメータを通じて関節角度指令に直接マッピングします。これはよりシンプルですが、物理的に意味のある動作を生成するためにマッピングパラメータの慎重な手動調整が必要です。

CPGベースのアプローチの重要な制限は、**物理的なバランスを本質的に保証しない**ことです。ZMPベースやDCMベースの手法（第3章と第5章）が動的に安定な軌道を明示的に計算するのとは異なり、CPGはロボットのバランスを保つかどうかに関わらずリズミックなパターンを生成します。実際には、CPGコントローラはバランスフィードバックループと組み合わせるか、モデルベースコントローラの参照軌道生成器として使用されることが多いです。

## CPG制御の利点

1. **頑健性**: 本質的に安定なリズミックパターン
2. **適応性**: 歩容間の滑らかな遷移
3. **低次元性**: 少数のパラメータで複雑な運動を制御
4. **感覚統合**: フィードバックがリズムを自然に変調
5. **分散型**: 中央計算のボトルネックがない

### 他のトピックとの関連

- **強化学習（第11章）**: CPGは強化学習ポリシーの行動空間として使用されることがあります。生の関節トルク（高次元）を学習する代わりに、RLエージェントはCPGパラメータ（低次元）を学習します。これにより、探索が容易な構造化された表現が提供され、より滑らかな動作につながります。
- **受動歩行（第4章）**: 受動歩行者はリミットサイクル挙動を示し、歩行パターンが状態空間のアトラクタとなります。CPGはこのリミットサイクル構造を制御された設定で再現し、同じエネルギー効率の良い周期的歩容を実現しながら、速度や歩容パラメータの変調を可能にします。
- **全身制御（第8章）**: CPGの出力は全身コントローラの参照軌道として使用できます。CPGが望ましいリズミック運動パターンを生成し、全身コントローラがバランスと接触拘束を満たしながらこのパターンを追従することを保証します。

## 参考文献

- A. Ijspeert, "[Central pattern generators for locomotion control in animals and robots: A review](https://doi.org/10.1016/j.neunet.2008.03.014)," *Neural Networks*, 2008.
- L. Righetti and A. Ijspeert, "[Pattern generators with sensory feedback for the control of quadruped locomotion](https://doi.org/10.1109/ROBOT.2008.4543306)," *Proc. IEEE ICRA*, 2008.

<InteractiveDemo title="CPG Oscillator Network">
  <p className="text-sm text-gray-500">
    Interactive CPG network with adjustable coupling coming soon.
  </p>
</InteractiveDemo>
