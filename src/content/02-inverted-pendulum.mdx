import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { LIPMDiagram, WalkingTransitionDiagram } from "@/components/diagrams/InvertedPendulumDiagram";
import { LIPMPhasePlaneDiagram } from "@/components/diagrams/LIPMPhasePlaneDiagram";

# Inverted Pendulum Model

The inverted pendulum is one of the most fundamental models in bipedal walking research.
By approximating the walker as a point mass atop a massless leg, we can derive tractable
equations of motion that capture the essential dynamics of walking.

## Cart-Pole System

Before discussing walking, consider the classic cart-pole (inverted pendulum on a cart).
The equation of motion for a simple inverted pendulum of length $l$ and mass $m$ is:

$$
ml^2 \ddot{\theta} - mgl\sin\theta = \tau
$$

For small angles ($\sin\theta \approx \theta$), this linearizes to:

$$
\ddot{\theta} - \frac{g}{l}\theta = \frac{\tau}{ml^2}
$$

This is an **unstable** system. To see why, rewrite the linearized equation in state-space form.
Define the state vector $\mathbf{x} = [\theta, \dot{\theta}]^T$. With $\tau = 0$ (no control input), we get:

$$
\begin{bmatrix} \dot{\theta} \\ \ddot{\theta} \end{bmatrix} = \begin{bmatrix} 0 & 1 \\ g/l & 0 \end{bmatrix} \begin{bmatrix} \theta \\ \dot{\theta} \end{bmatrix}
$$

The eigenvalues of the system matrix $A$ are found from $\det(A - \lambda I) = 0$:

$$
\lambda^2 - \frac{g}{l} = 0 \quad \Rightarrow \quad \lambda = \pm\sqrt{\frac{g}{l}}
$$

The positive eigenvalue $\lambda_+ = +\sqrt{g/l}$ corresponds to an exponentially
divergent mode, while $\lambda_- = -\sqrt{g/l}$ corresponds to a convergent mode.
Any small perturbation will excite the divergent mode, causing the pendulum to
fall over exponentially fast. This is fundamentally why walking is difficult:
bipedal locomotion is essentially the act of continuously stabilizing an
unstable system. Without active control (or careful passive dynamics), the
walker will inevitably fall.

## Linear Inverted Pendulum Model (LIPM)

The Linear Inverted Pendulum Model constrains the center of mass (CoM) to move
at a constant height $z_c$. This dramatically simplifies the dynamics.

<LIPMDiagram />

### Derivation

Consider a point mass $m$ at position $(x, z_c)$ with a massless leg contacting
the ground at point $p_x$. The constraint force acts along the leg.

From Newton's second law in the horizontal and vertical directions:

$$
m\ddot{x} = F_x, \quad m\ddot{z} = F_z - mg
$$

Since $z = z_c$ is constant, $\ddot{z} = 0$, so $F_z = mg$.

### Eliminating the Constraint Force

The key step is to recognize that because the leg is **rigid and massless**,
the constraint force $F$ must act **along the direction of the leg**. If there
were any component perpendicular to the leg, it would cause infinite angular
acceleration of the massless leg, which is unphysical.

The leg points from the support point $(p_x, 0)$ to the CoM $(x, z_c)$.
If we let $\theta$ be the angle of the leg from the vertical, we can decompose
the constraint force $F$ into its horizontal and vertical components by the
geometry of the triangle formed by the leg:

$$
F_x = F \sin\theta = F \cdot \frac{x - p_x}{L}, \quad F_z = F \cos\theta = F \cdot \frac{z_c}{L}
$$

where $L = \sqrt{(x - p_x)^2 + z_c^2}$ is the leg length. Taking the ratio
of these two equations eliminates both $F$ and $L$:

$$
\frac{F_x}{F_z} = \frac{x - p_x}{z_c}
$$

Substituting $F_z = mg$ (from the vertical equation) gives:

$$
m\ddot{x} = \frac{mg}{z_c}(x - p_x)
$$

This yields the fundamental LIPM equation:

<MathBlock tex="\ddot{x} = \frac{g}{z_c}(x - p_x)" />

where $x$ is the CoM position, $p_x$ is the foot (support point) position,
$g$ is gravitational acceleration, and $z_c$ is the constant CoM height.

### Natural Frequency

Define the natural frequency:

$$
\omega = \sqrt{\frac{g}{z_c}}
$$

The LIPM equation becomes $\ddot{x} = \omega^2(x - p_x)$.

### Analytical Solution

With support point at the origin ($p_x = 0$), the general solution is:

$$
x(t) = x_0 \cosh(\omega t) + \frac{\dot{x}_0}{\omega}\sinh(\omega t)
$$

$$
\dot{x}(t) = x_0 \omega \sinh(\omega t) + \dot{x}_0 \cosh(\omega t)
$$

where $x_0 = x(0)$ and $\dot{x}_0 = \dot{x}(0)$ are the initial conditions.

Note the use of hyperbolic functions ($\cosh$, $\sinh$) rather than trigonometric
functions ($\cos$, $\sin$) â€” this reflects the unstable (divergent) nature of
the inverted pendulum dynamics.

## 3D Extension (3D-LIPM)

The LIPM extends naturally to 3D. With the CoM constrained to height $z_c$:

$$
\ddot{x} = \frac{g}{z_c}(x - p_x), \quad \ddot{y} = \frac{g}{z_c}(y - p_y)
$$

The $x$ and $y$ dynamics are **decoupled**, which is a major advantage
for walking pattern generation: we can plan sagittal and lateral motions independently.

## Orbital Energy

A useful concept for analyzing LIPM dynamics is the **orbital energy**:

$$
E = \frac{1}{2}\dot{x}^2 - \frac{1}{2}\omega^2(x - p_x)^2
$$

This quantity is conserved during single-support phases. Trajectories with:
- $E > 0$: the CoM passes over the support point (walking)
- $E = 0$: the CoM asymptotically approaches or leaves the support point
- $E < 0$: the CoM oscillates around the support point (not physically meaningful for walking)

### Intuitive Understanding of Orbital Energy

To build intuition, consider the analogy of a ball rolling on a hill.
Imagine a ball on a landscape shaped like a saddle: the ball can either
roll over the hill if it has enough kinetic energy, or get stuck oscillating
in a valley if it does not. The orbital energy $E$ plays the role of the
total mechanical energy in this analogy.

When $E > 0$, the CoM has enough kinetic energy to "vault over" the
support point. This is the walking regime: the body passes over one
foot and continues forward to the next step. In a typical walking gait,
the orbital energy stays positive throughout each single-support phase.

When $E = 0$, the trajectory lies exactly on the **separatrix** (the
boundary between the walking and non-walking regions). In this case,
the CoM would take infinitely long to reach or depart from the support
point. This is a theoretical boundary that is never exactly realized
in practice, but it defines the minimum energy needed for walking.

The conservation of orbital energy is powerful because it means the
entire trajectory is determined by the initial state alone. If you know
the position and velocity of the CoM at any instant during a single-support
phase, you can predict where the CoM will be at every other instant.
This makes the LIPM analytically tractable and is one of the main reasons
it is so widely used in walking pattern generation.

### Phase Plane Visualization

The phase plane plots position $x$ against velocity $\dot{x}$ and reveals
the global structure of the dynamics. Each curve in the diagram below
represents a constant orbital energy level.

<LIPMPhasePlaneDiagram />

## Python Simulation: LIPM Trajectory

<CodeEditor
  initialCode={`import math

# LIPM parameters
g = 9.81      # gravity (m/s^2)
z_c = 0.8     # CoM height (m)
omega = math.sqrt(g / z_c)  # natural frequency

print(f"Natural frequency: omega = {omega:.3f} rad/s")
print(f"Time constant: 1/omega = {1/omega:.3f} s")
print()

# Initial conditions
x0 = -0.1    # initial CoM position (m)
xd0 = 0.3    # initial CoM velocity (m/s)
p_x = 0.0    # support point at origin

# Simulate LIPM trajectory
dt = 0.01
t_end = 1.0
steps = int(t_end / dt)

print("Time(s)  x(m)     xdot(m/s)  Energy")
print("-" * 45)

time_list = []
x_list = []
xdot_list = []

for i in range(0, steps + 1):
    t = i * dt
    # Analytical solution (support at origin)
    x = x0 * math.cosh(omega * t) + (xd0 / omega) * math.sinh(omega * t)
    xdot = x0 * omega * math.sinh(omega * t) + xd0 * math.cosh(omega * t)
    time_list.append(t)
    x_list.append(x)
    xdot_list.append(xdot)
    # Orbital energy (should be conserved)
    if i % 10 == 0:
        energy = 0.5 * xdot**2 - 0.5 * omega**2 * x**2
        print(f"{t:5.2f}    {x:7.4f}  {xdot:7.4f}    {energy:7.4f}")

# Plot time series and phase plane
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

fig, axes = plt.subplots(2, 1, figsize=(8, 6))

# Upper: time series of x(t) and xdot(t)
axes[0].plot(time_list, x_list, label='x(t) [m]', color='tab:blue')
axes[0].plot(time_list, xdot_list, label='xdot(t) [m/s]',
             color='tab:orange')
axes[0].set_xlabel('Time [s]')
axes[0].set_ylabel('Value')
axes[0].set_title('LIPM Trajectory: Time Series')
axes[0].legend()
axes[0].grid(True, alpha=0.3)

# Lower: phase plane (x vs xdot)
axes[1].plot(x_list, xdot_list, color='tab:green', linewidth=2)
axes[1].plot(x_list[0], xdot_list[0], 'o', color='tab:blue',
             markersize=8, label='Start')
axes[1].plot(x_list[-1], xdot_list[-1], 's', color='tab:red',
             markersize=8, label='End')
axes[1].set_xlabel('x [m]')
axes[1].set_ylabel('xdot [m/s]')
axes[1].set_title('LIPM Trajectory: Phase Plane')
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## Walking with LIPM

<WalkingTransitionDiagram />

To generate a walking pattern, we chain multiple single-support phases together.
At each step transition, the support point shifts to the new foot position.

### Step-to-Step Transition Map

The **step-to-step transition map** is a function that takes the state
$(x, \dot{x})$ at the end of one single-support phase (measured relative to
the current support foot) and maps it to the state at the beginning of the
next phase (measured relative to the new support foot). When the robot takes
a step of length $d$, the position in the new coordinate frame becomes
$x_{\text{new}} = x_{\text{end}} - d$, while the velocity is unchanged:
$\dot{x}_{\text{new}} = \dot{x}_{\text{end}}$.

A **periodic gait** exists when the transition map has a **fixed point**:
the state at the start of each step is identical. This means the robot
repeats the same trajectory every step, which is exactly what steady-state
walking looks like.

### Why the Initial Velocity Uses tanh

For a periodic gait with step duration $T$ and step length $d$, we require
the CoM to start at $x = -d/2$ (behind the support foot) and end at
$x = +d/2$ (ahead of it) due to symmetry. Substituting into the LIPM
analytical solution and solving for the initial velocity $\dot{x}_0$ gives:

$$
\dot{x}_0 = \frac{d/2 \cdot \omega}{\tanh(\omega T / 2)}
$$

The $\tanh$ function appears because $\cosh$ and $\sinh$ satisfy
$\cosh^2 - \sinh^2 = 1$, and the symmetry condition requires the ratio
$x_0 / (\dot{x}_0 / \omega) = -\tanh(\omega T / 2)$. Since
$\tanh(\omega T / 2) < 1$, the required initial velocity is always larger
than $d \omega / 2$, reflecting the extra energy needed to overcome the
unstable dynamics.

<CodeEditor
  initialCode={`import math

# LIPM walking simulation
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)
T_step = 0.4  # step duration (s)

# Step length pattern (alternating feet)
step_length = 0.2  # meters

# Start at the support foot
x = -step_length / 2  # CoM starts behind support
xdot = (step_length / 2) * omega / math.tanh(omega * T_step / 2)

print(f"Step duration: {T_step:.2f} s")
print(f"Step length: {step_length:.2f} m")
print(f"Initial velocity: {xdot:.4f} m/s")
print()

support_x = 0.0
print("Step  t(s)    CoM_x(m)  Velocity(m/s)  Support(m)")
print("-" * 55)

num_steps = 5
dt = 0.01
com_trajectory = []
support_points = [support_x]

for step in range(num_steps):
    # Simulate one step
    n_substeps = int(T_step / dt) + 1
    for i in range(n_substeps):
        t = i * dt
        dx = x - support_x
        x_t = (support_x + dx * math.cosh(omega * t)
               + (xdot / omega) * math.sinh(omega * t))
        xdot_t = (dx * omega * math.sinh(omega * t)
                  + xdot * math.cosh(omega * t))
        com_trajectory.append(x_t)

    # State at end of step
    x = x_t
    xdot = xdot_t
    print(f"  {step}    {(step+1)*T_step:.2f}   {x:8.4f}"
          f"     {xdot:8.4f}      {support_x:.3f}")

    # Transition: shift support to new foot
    support_x += step_length
    support_points.append(support_x)

# Plot multi-step CoM trajectory
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

total_samples = len(com_trajectory)
time_array = [i * dt for i in range(total_samples)]

fig, ax = plt.subplots(figsize=(10, 4))
ax.plot(time_array, com_trajectory, color='tab:blue',
        linewidth=1.5, label='CoM x(t)')

# Mark support point transitions
for idx, sp in enumerate(support_points):
    t_switch = idx * T_step
    ax.axvline(x=t_switch, color='gray', linestyle='--',
               alpha=0.5)
    ax.plot(t_switch, sp, 'v', color='tab:red', markersize=10,
            label='Support' if idx == 0 else None)

ax.set_xlabel('Time [s]')
ax.set_ylabel('x position [m]')
ax.set_title('Multi-Step LIPM Walking: CoM Trajectory')
ax.legend()
ax.grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## Simulation: LIPM Phase Portrait

The phase portrait reveals the global structure of LIPM dynamics.
Trajectories are classified by their orbital energy $E$:
positive energy (walking), zero energy (separatrix), and negative energy (oscillation).

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# LIPM model parameters
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)

print(f"omega = {omega:.3f} rad/s")
print()

# Generate phase portrait
x_range = np.linspace(-0.3, 0.3, 400)

fig, ax = plt.subplots(figsize=(8, 6))

# E < 0: oscillatory trajectories (not physical for walking)
energy_neg = [-0.01, -0.03, -0.06]
for e_val in energy_neg:
    # xdot^2 = 2*E + omega^2 * x^2, only valid where >= 0
    xdot_sq = 2 * e_val + omega**2 * x_range**2
    valid = xdot_sq >= 0
    if np.any(valid):
        xdot_pos = np.sqrt(xdot_sq[valid])
        ax.plot(x_range[valid], xdot_pos,
                color='tab:blue', alpha=0.7, linewidth=1)
        ax.plot(x_range[valid], -xdot_pos,
                color='tab:blue', alpha=0.7, linewidth=1)
    print(f"E = {e_val:.2f}: closed orbit (oscillation)")

# E = 0: separatrix
xdot_sep_pos = omega * np.abs(x_range)
ax.plot(x_range, xdot_sep_pos, color='black',
        linewidth=3, label='E = 0 (separatrix)')
ax.plot(x_range, -xdot_sep_pos, color='black',
        linewidth=3)
print(f"E =  0.00: separatrix (boundary)")

# E > 0: walking trajectories
energy_pos = [0.01, 0.03, 0.06]
for e_val in energy_pos:
    xdot_sq = 2 * e_val + omega**2 * x_range**2
    xdot_pos = np.sqrt(xdot_sq)
    ax.plot(x_range, xdot_pos,
            color='tab:red', alpha=0.7, linewidth=1)
    ax.plot(x_range, -xdot_pos,
            color='tab:red', alpha=0.7, linewidth=1)
    print(f"E = {e_val:5.2f}: open orbit (walking)")

# Labels and formatting
ax.set_xlabel('x [m]', fontsize=12)
ax.set_ylabel('xdot [m/s]', fontsize=12)
ax.set_title('LIPM Phase Portrait', fontsize=14)
ax.axhline(y=0, color='gray', linewidth=0.5)
ax.axvline(x=0, color='gray', linewidth=0.5)

# Custom legend
from matplotlib.lines import Line2D
legend_items = [
    Line2D([0], [0], color='tab:red', linewidth=2,
           label='E > 0 (walking)'),
    Line2D([0], [0], color='black', linewidth=3,
           label='E = 0 (separatrix)'),
    Line2D([0], [0], color='tab:blue', linewidth=2,
           label='E < 0 (oscillation)'),
]
ax.legend(handles=legend_items, fontsize=11)
ax.grid(True, alpha=0.3)
ax.set_xlim(-0.3, 0.3)
ax.set_ylim(-1.2, 1.2)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## Limitations of LIPM

While powerful, the LIPM has important limitations:

1. **Constant height assumption**: real walking involves vertical CoM motion
2. **Point mass**: ignores angular momentum of limbs and torso
3. **Massless legs**: leg swing dynamics are not captured
4. **No double support**: transitions are instantaneous

These limitations motivate more advanced models covered in later chapters.

## References

- S. Kajita et al., "[The 3D Linear Inverted Pendulum Mode: A simple modeling for a biped walking pattern generation](https://doi.org/10.1109/IROS.2001.973365)," *Proc. IEEE/RSJ IROS*, 2001.
- S. Kajita et al., "[Biped Walking Pattern Generation by using Preview Control of Zero-Moment Point](https://doi.org/10.1109/ROBOT.2003.1241826)," *Proc. IEEE ICRA*, 2003.

<InteractiveDemo title="LIPM Simulation">
  <p className="text-sm text-gray-500">
    Interactive LIPM simulation with adjustable parameters coming soon.
  </p>
</InteractiveDemo>
