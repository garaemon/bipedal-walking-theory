import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { ZMPConceptDiagram, ZMPSupportPolygonDiagram } from "@/components/diagrams/ZMPDiagram";
import { ZMPStabilityDiagram } from "@/components/diagrams/ZMPStabilityDiagram";

# Zero Moment Point (ZMP)

The Zero Moment Point is a foundational concept in bipedal walking that provides
a criterion for dynamic balance. Introduced by Vukobratovic and Juricic in 1969,
ZMP theory has been the basis of most humanoid walking controllers for decades.

## Definition

The **Zero Moment Point** is the point on the ground where the net moment of all
active forces (gravity and inertia) has zero horizontal components.

### Derivation from First Principles

To understand where the ZMP formula comes from, consider a point
$P = (p_x, 0, 0)$ on the ground. Each mass $m_i$ at position
$(x_i, y_i, z_i)$ experiences two forces: gravity $-m_i g \hat{z}$
and inertial force $-m_i \mathbf{a}_i$ (d'Alembert's principle). The
moment of these forces about point $P$ is:

$$
\boldsymbol{\tau}_P = \sum_{i=1}^{n} (\mathbf{r}_i - \mathbf{r}_P) \times (-m_i g \hat{z} - m_i \mathbf{a}_i)
$$

We define the ZMP as the point $P$ where the **horizontal components**
of this moment vanish. Setting $\tau_{P,y} = 0$ (the moment about the
$y$-axis) and solving for $p_x$ yields the ZMP formula.

For a system of $n$ point masses, the ZMP position is:

<MathBlock tex="p_x^{zmp} = \frac{\sum_{i=1}^{n} m_i (\ddot{z}_i + g) x_i - \sum_{i=1}^{n} m_i \ddot{x}_i z_i}{\sum_{i=1}^{n} m_i (\ddot{z}_i + g)}" />

<MathBlock tex="p_y^{zmp} = \frac{\sum_{i=1}^{n} m_i (\ddot{z}_i + g) y_i - \sum_{i=1}^{n} m_i \ddot{y}_i z_i}{\sum_{i=1}^{n} m_i (\ddot{z}_i + g)}" />

<ZMPConceptDiagram />

## Physical Meaning

The ZMP is equivalent to the **Center of Pressure (CoP)** — the point where the
ground reaction force effectively acts — as long as the robot is in stable contact
with the ground.

Consider a single point mass at $(x, y, z)$. The ZMP simplifies to:

$$
p_x^{zmp} = x - \frac{z \ddot{x}}{\ddot{z} + g}
$$

For the LIPM case where $z = z_c$ (constant) and $\ddot{z} = 0$:

$$
p_x^{zmp} = x - \frac{z_c}{g}\ddot{x}
$$

This is exactly the support point $p_x$ from the LIPM equation
$\ddot{x} = \frac{g}{z_c}(x - p_x)$.

## Support Polygon

The **support polygon** is the convex hull of all contact points between the robot
and the ground.

- **Single support**: the support polygon is the footprint of the stance foot
- **Double support**: the support polygon includes both feet

<ZMPSupportPolygonDiagram />

### ZMP Stability Criterion

A robot maintains dynamic balance if and only if:

> The ZMP lies within the support polygon.

If the ZMP reaches the edge of the support polygon, the robot begins to tip over.
This is the fundamental constraint used in walking pattern generation.

<ZMPStabilityDiagram />

## ZMP vs CoP vs CoG

| Concept | Definition | Use case |
|---------|-----------|----------|
| **CoG** (Center of Gravity) | Weighted average position of all masses | Static balance |
| **CoP** (Center of Pressure) | Point where ground reaction force acts | Measurable quantity |
| **ZMP** (Zero Moment Point) | Point where horizontal moments vanish | Dynamic balance criterion |

For a robot in stable ground contact, ZMP = CoP. When the computed ZMP exits the
support polygon, the actual CoP remains at the polygon edge, and the robot tilts.

## Computing ZMP from Motion Data

Given a trajectory of the center of mass, we can compute the ZMP:

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Simulate a simple CoM trajectory and compute ZMP
# Using a sinusoidal CoM motion
g = 9.81
z_c = 0.8  # constant CoM height

# Time parameters
dt = 0.01
t_values = [i * dt for i in range(101)]

# CoM trajectory: x(t) = A * sin(omega_walk * t)
A = 0.05        # amplitude (m)
omega_walk = 2 * math.pi / 0.6  # walking frequency

print("Time(s)  CoM_x(m)  CoM_xdd(m/s^2)  ZMP_x(m)")
print("-" * 50)

com_x_list = []
zmp_x_list = []

for i, t in enumerate(t_values):
    # CoM position and acceleration
    x = A * math.sin(omega_walk * t)
    xdd = -A * omega_walk**2 * math.sin(omega_walk * t)

    # ZMP computation (constant height, no vertical acceleration)
    zmp_x = x - (z_c / g) * xdd

    com_x_list.append(x)
    zmp_x_list.append(zmp_x)

    if i % 10 == 0:
        print(f"{t:5.2f}    {x:8.5f}    {xdd:8.4f}       {zmp_x:8.5f}")

# Plot CoM and ZMP trajectories
t_arr = np.array(t_values)
fig, axes = plt.subplots(2, 1, figsize=(8, 5), sharex=True)

axes[0].plot(t_arr, np.array(com_x_list) * 100, "b-", linewidth=2)
axes[0].set_ylabel("CoM x [cm]")
axes[0].set_title("CoM Trajectory")
axes[0].grid(True, alpha=0.3)

axes[1].plot(t_arr, np.array(com_x_list) * 100, "b-",
             linewidth=1.5, label="CoM x")
axes[1].plot(t_arr, np.array(zmp_x_list) * 100, "r--",
             linewidth=2, label="ZMP x")
axes[1].set_xlabel("Time [s]")
axes[1].set_ylabel("Position [cm]")
axes[1].set_title("ZMP vs CoM (note ZMP phase lead)")
axes[1].legend()
axes[1].grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## ZMP for Multi-Body Systems

For a robot with multiple rigid body links, the ZMP computation sums over all links:

$$
p_x^{zmp} = \frac{\sum_{i=1}^{N} m_i(g + \ddot{z}_{G_i})x_{G_i} - \sum_{i=1}^{N}(m_i \ddot{x}_{G_i} z_{G_i} + I_{iy}\ddot{\theta}_{iy})}{\sum_{i=1}^{N} m_i(g + \ddot{z}_{G_i})}
$$

where $(x_{G_i}, z_{G_i})$ is the center of mass of link $i$, $I_{iy}$ is the
moment of inertia about the $y$-axis, and $\ddot{\theta}_{iy}$ is the angular
acceleration. The term $I_{iy}\ddot{\theta}_{iy}$ represents the **angular
momentum contribution** of each link: when a link rotates (e.g., swinging
an arm), the rate of change of its angular momentum generates a moment
about the ground contact. This shifts the ZMP away from where the
point-mass model would predict. For slow walking, these angular momentum
terms are small and often neglected (yielding the simpler point-mass
ZMP formula). For dynamic motions like running or kicking, they become
significant.

## ZMP-Based Walking Pattern Generation

The typical pipeline for ZMP-based walking:

1. **Define footstep sequence**: positions and timing of each step
2. **Design ZMP reference**: a trajectory that stays within support polygons
3. **Solve for CoM trajectory**: find CoM motion that produces the desired ZMP
4. **Generate joint trajectories**: use inverse kinematics

Step 3 is the core computational challenge, addressed by preview control
(Chapter 5).

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# ZMP reference trajectory for 3-step walk
# Simplified: ZMP shifts between left and right foot positions

foot_y_left = 0.05    # left foot y-position (m)
foot_y_right = -0.05  # right foot y-position (m)
foot_width = 0.06     # foot width in y-direction (m)
step_duration = 0.6   # seconds per step
dt = 0.01

# Footstep plan (y-positions of support foot)
footsteps = [
    (0.0, foot_y_left),         # step 1: left support
    (step_duration, foot_y_right),  # step 2: right support
    (2 * step_duration, foot_y_left),   # step 3: left support
]

print("=== ZMP Reference Trajectory (Lateral) ===")
print("Time(s)  ZMP_ref_y(m)  Support")
print("-" * 40)

total_time = 3 * step_duration
t = 0.0
t_list = []
zmp_ref_list = []
while t <= total_time:
    # Determine current support phase
    phase = int(t / step_duration)
    if phase >= len(footsteps):
        phase = len(footsteps) - 1

    zmp_ref_y = footsteps[phase][1]
    support = "Left" if zmp_ref_y > 0 else "Right"

    t_list.append(t)
    zmp_ref_list.append(zmp_ref_y)

    if int(t * 100) % 10 == 0:
        print(f"{t:5.2f}    {zmp_ref_y:8.4f}      {support}")
    t += dt

print()
print("The ZMP reference alternates between feet.")
print("Preview control (Ch.5) computes the CoM trajectory")
print("that tracks this ZMP reference.")

# Plot footstep rectangles and ZMP reference trajectory
fig, ax = plt.subplots(figsize=(8, 4))

colors = ["#4a90d9", "#d94a4a", "#4a90d9"]
labels_used = set()
for i, (t_start, foot_y) in enumerate(footsteps):
    t_end = t_start + step_duration
    y_lo = foot_y - foot_width / 2
    y_hi = foot_y + foot_width / 2
    side = "Left foot" if foot_y > 0 else "Right foot"
    lbl = side if side not in labels_used else None
    labels_used.add(side)
    ax.fill_between(
        [t_start, t_end], y_lo * 100, y_hi * 100,
        alpha=0.2, color=colors[i], label=lbl
    )
    ax.plot(
        [t_start, t_end, t_end, t_start, t_start],
        [y_lo * 100, y_lo * 100, y_hi * 100, y_hi * 100, y_lo * 100],
        color=colors[i], linewidth=1
    )

# Step transition lines
for i in range(1, len(footsteps)):
    t_switch = footsteps[i][0]
    ax.axvline(t_switch, color="gray", linestyle="--",
               linewidth=1, alpha=0.7,
               label="Step transition" if i == 1 else None)

ax.plot(t_list, np.array(zmp_ref_list) * 100, "k-",
        linewidth=2, label="ZMP ref")
ax.set_xlabel("Time [s]")
ax.set_ylabel("Lateral position [cm]")
ax.set_title("ZMP Reference Trajectory with Support Polygons")
ax.legend(loc="upper right", fontsize=8)
ax.grid(True, alpha=0.3)

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## Simulation: Visualizing ZMP Stability

The following simulation demonstrates the ZMP stability criterion by comparing gentle CoM motion (stable) with aggressive acceleration that causes the ZMP to leave the support polygon (unstable).

<CodeEditor
  initialCode={`import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

g = 9.81
z_c = 0.8  # constant CoM height (m)

# Support polygon boundaries (single foot, x-direction)
foot_length = 0.20  # 20 cm foot
support_min = -foot_length / 2
support_max = foot_length / 2

dt = 0.005
t_arr = np.arange(0, 1.0, dt)

def compute_zmp_trajectory(amplitude, omega):
    """Compute CoM and ZMP for sinusoidal CoM motion."""
    com_x = amplitude * np.sin(omega * t_arr)
    com_xdd = -amplitude * omega**2 * np.sin(omega * t_arr)
    zmp_x = com_x - (z_c / g) * com_xdd
    return com_x, zmp_x

# Case 1: Stable (small amplitude, low frequency)
com_stable, zmp_stable = compute_zmp_trajectory(0.03, 2.0 * np.pi)

# Case 2: Unstable (large amplitude, high frequency)
com_unstable, zmp_unstable = compute_zmp_trajectory(0.08, 4.0 * np.pi)

fig, axes = plt.subplots(1, 2, figsize=(10, 4))

for ax, com_x, zmp_x, title in [
    (axes[0], com_stable, zmp_stable, "Stable: ZMP inside polygon"),
    (axes[1], com_unstable, zmp_unstable, "Unstable: ZMP exits polygon"),
]:
    # Support polygon background
    ax.fill_between(
        t_arr, support_min * 100, support_max * 100,
        alpha=0.15, color="green", label="Support polygon"
    )
    ax.axhline(support_min * 100, color="green",
               linestyle="-", linewidth=1.5, alpha=0.6)
    ax.axhline(support_max * 100, color="green",
               linestyle="-", linewidth=1.5, alpha=0.6)

    # Color ZMP by stability
    zmp_cm = zmp_x * 100
    in_support = (zmp_x >= support_min) & (zmp_x <= support_max)
    out_support = ~in_support

    # Plot ZMP segments with different colors
    ax.plot(t_arr, zmp_cm, color="gray", linewidth=0.5, alpha=0.3)
    if np.any(in_support):
        t_in = t_arr.copy()
        z_in = zmp_cm.copy()
        z_in[out_support] = np.nan
        ax.plot(t_in, z_in, "b-", linewidth=2, label="ZMP (stable)")
    if np.any(out_support):
        t_out = t_arr.copy()
        z_out = zmp_cm.copy()
        z_out[in_support] = np.nan
        ax.plot(t_out, z_out, "r-", linewidth=2.5, label="ZMP (unstable)")

    ax.plot(t_arr, com_x * 100, "k--", linewidth=1, alpha=0.6,
            label="CoM")
    ax.set_xlabel("Time [s]")
    ax.set_ylabel("x position [cm]")
    ax.set_title(title)
    ax.legend(fontsize=7, loc="upper right")
    ax.grid(True, alpha=0.3)
    ax.set_ylim([-15, 15])

plt.tight_layout()
buf = io.BytesIO()
plt.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()

# Print summary
n_total = len(t_arr)
stable_in = np.sum(
    (zmp_stable >= support_min) & (zmp_stable <= support_max)
)
unstable_in = np.sum(
    (zmp_unstable >= support_min) & (zmp_unstable <= support_max)
)
print(f"Stable case:   {stable_in}/{n_total} samples inside polygon "
      f"({100*stable_in/n_total:.1f}%)")
print(f"Unstable case: {unstable_in}/{n_total} samples inside polygon "
      f"({100*unstable_in/n_total:.1f}%)")
print()
print("When CoM acceleration is too large, the ZMP (red) exits")
print("the support polygon, indicating the robot would tip over.")
`}
/>

## Limitations of ZMP

1. **Conservative**: ZMP criterion only considers ground contact forces; it does
   not account for angular momentum, making it overly restrictive
2. **Flat ground assumption**: extending ZMP to uneven terrain requires modifications
3. **No push recovery**: ZMP-based walkers cannot recover from large perturbations
   that push the ZMP outside the support polygon

These limitations led to the development of **Capture Point** theory (Chapter 6).

## References

- M. Vukobratovic and J. Juricic, "[Contribution to the synthesis of biped gait](https://doi.org/10.1109/tbme.1969.4502596)," *IEEE Trans. Bio-Medical Engineering*, 1969.
- M. Vukobratovic and B. Borovac, "[Zero-Moment Point — Thirty five years of its life](https://www.cs.cmu.edu/~cga/legs/vukobratovic.pdf)," *Int. J. Humanoid Robotics*, 2004. ([DOI](https://doi.org/10.1142/S0219843604000083))

<InteractiveDemo title="ZMP Visualization">
  <p className="text-sm text-gray-500">
    Interactive ZMP trajectory and support polygon visualization coming soon.
  </p>
</InteractiveDemo>
