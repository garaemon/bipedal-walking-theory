import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { CPGNetworkDiagram } from "@/components/diagrams/CPGDiagram";
import { HopfOscillatorDiagram } from "@/components/diagrams/HopfOscillatorDiagram";

# Central Pattern Generators (CPG)

Central Pattern Generators are neural circuits found in vertebrate spinal cords
that produce rhythmic motor patterns without requiring rhythmic sensory input.
CPG-based controllers offer a biologically inspired approach to locomotion.

## Biological Background

In animals, CPGs in the spinal cord generate the basic rhythmic patterns for
walking, swimming, and flying. Key properties:

- **Autonomous rhythm**: produce oscillations without external timing
- **Sensory modulation**: feedback adjusts frequency, amplitude, and phase
- **Robustness**: continue functioning despite perturbations

## Coupled Oscillator Model

A CPG network consists of oscillators coupled with specific phase relationships.
The phase model of a CPG network is:

<MathBlock tex="\dot{\phi}_i = \omega_i + \sum_{j} w_{ij} \sin(\phi_j - \phi_i - \psi_{ij})" />

where:
- $\phi_i$ is the phase of oscillator $i$
- $\omega_i$ is the intrinsic frequency
- $w_{ij}$ is the coupling weight from oscillator $j$ to $i$
- $\psi_{ij}$ is the desired phase difference

<CPGNetworkDiagram />

### Why Coupled Oscillators Converge

It is not immediately obvious why this coupling law forces the oscillators into
the desired phase relationships. To see why, define the phase error between
oscillators $i$ and $j$ as:

$$
e_{ij} = \phi_j - \phi_i - \psi_{ij}
$$

When the oscillators are synchronized at the desired relationship, $e_{ij} = 0$.
Near this synchronized state, the coupling term $w_{ij}\sin(e_{ij})$ behaves
like a **restoring force**: if $e_{ij}$ is small and positive (the phase
difference is larger than desired), $\sin(e_{ij}) > 0$ pulls oscillator $i$
forward to close the gap. If $e_{ij}$ is negative, the force reverses.

To analyze stability more rigorously, linearize $\sin(e_{ij}) \approx e_{ij}$
near $e_{ij}=0$. The dynamics of the error become:

$$
\dot{e}_{ij} \approx -(w_{ij} + w_{ji})\, e_{ij}
$$

As long as the coupling weights are positive, this is a stable first-order
system with exponential convergence. The coupling acts exactly like a spring
(with stiffness $w_{ij} + w_{ji}$) that keeps the oscillators "locked" in
the correct phase relationship. Stronger coupling weights produce faster
convergence but can also make the system stiffer and less adaptive.

## Phase Coordination for Walking

For bipedal walking, the key phase relationships are:

| Joint pair | Phase offset | Meaning |
|-----------|-------------|---------|
| Left hip - Right hip | $\pi$ | Alternating legs |
| Hip - Knee (same leg) | $\pi/2$ | Knee leads hip by quarter cycle |
| Left knee - Right knee | $\pi$ | Anti-phase |

## Amplitude-Controlled CPG

A more complete CPG model includes amplitude control using the Hopf oscillator:

$$
\dot{x}_i = \alpha(\mu_i - r_i^2)x_i - \omega_i y_i
$$

$$
\dot{y}_i = \alpha(\mu_i - r_i^2)y_i + \omega_i x_i
$$

where $r_i = \sqrt{x_i^2 + y_i^2}$, $\mu_i$ controls the amplitude, and
$\alpha$ controls the convergence rate to the limit cycle.

### Hopf Oscillator Intuition

The equations above become much clearer when expressed in **polar coordinates**
$(r, \theta)$ where $x = r\cos\theta$ and $y = r\sin\theta$:

$$
\dot{r} = \alpha(\mu - r^2)\,r, \quad \dot{\theta} = \omega
$$

The angular equation $\dot{\theta} = \omega$ simply means the oscillator
rotates at a constant frequency. The radial equation is where the key
behavior lies. Setting $\dot{r} = 0$ to find equilibria:

- $r = 0$ is an equilibrium, but it is **unstable**: if $r$ is slightly
  positive and $\mu > 0$, then $\mu - r^2 > 0$, so $\dot{r} > 0$ and
  $r$ grows.
- $r = \sqrt{\mu}$ is a **stable equilibrium**: if $r < \sqrt{\mu}$,
  then $\dot{r} > 0$ (amplitude grows); if $r > \sqrt{\mu}$, then
  $\dot{r} < 0$ (amplitude shrinks).

This means the amplitude **self-regulates** to $\sqrt{\mu}$ regardless of
initial conditions. This is the defining property of a **limit cycle**: it
attracts all nearby trajectories. The parameter $\alpha$ controls how quickly
this convergence happens.

<HopfOscillatorDiagram />

## Simulation: Hopf Oscillator Dynamics

The following simulation demonstrates how the Hopf oscillator converges to its limit cycle from different initial conditions. The left panel shows the trajectory in the x-y phase plane converging to a circle of radius $\sqrt{\mu}$, while the right panel shows the time evolution of the amplitude $r(t)$.

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Hopf oscillator parameters
mu = 1.0       # amplitude parameter -> limit cycle at r = sqrt(mu) = 1.0
alpha = 5.0    # convergence rate
omega = 2 * math.pi * 1.0  # oscillation frequency (1 Hz)

# Different initial radii to show convergence
initial_radii = [0.1, 0.5, 1.0, 1.5, 2.0]
dt = 0.002
sim_time = 3.0
num_steps = int(sim_time / dt)

print("=== Hopf Oscillator Simulation ===")
print(f"mu = {mu}, alpha = {alpha}, omega = {omega/(2*math.pi):.1f} Hz")
print(f"Limit cycle radius: r* = sqrt(mu) = {math.sqrt(mu):.2f}")
print()

def simulate_hopf(r0, mu_val, alpha_val, omega_val, dt_val, n_steps):
    """Simulate Hopf oscillator from initial radius r0."""
    x = r0
    y = 0.0
    xs, ys, rs, ts = [x], [y], [r0], [0.0]
    for k in range(1, n_steps):
        r_sq = x * x + y * y
        dx = alpha_val * (mu_val - r_sq) * x - omega_val * y
        dy = alpha_val * (mu_val - r_sq) * y + omega_val * x
        x += dx * dt_val
        y += dy * dt_val
        xs.append(x)
        ys.append(y)
        rs.append(math.sqrt(x * x + y * y))
        ts.append(k * dt_val)
    return xs, ys, rs, ts

# Run simulations and print summary
trajectories = {}
for r0 in initial_radii:
    xs, ys, rs, ts = simulate_hopf(r0, mu, alpha, omega, dt, num_steps)
    trajectories[r0] = (xs, ys, rs, ts)
    print(f"r0 = {r0:.1f} -> final r = {rs[-1]:.4f}")

print()
print("All trajectories converge to r = 1.0 (the limit cycle)")

def plot_hopf_phase_plane(traj_data, mu_val):
    """Plot Hopf oscillator phase plane and r(t) time series."""
    fig, axes = plt.subplots(1, 2, figsize=(11, 5))
    colors = ["#2563eb", "#16a34a", "#ea580c", "#dc2626", "#7c3aed"]
    r_star = np.sqrt(mu_val)

    ax_phase = axes[0]
    theta_circle = np.linspace(0, 2 * np.pi, 200)
    ax_phase.plot(
        r_star * np.cos(theta_circle),
        r_star * np.sin(theta_circle),
        "k--", linewidth=1.5, alpha=0.5,
        label=f"Limit cycle (r={r_star:.1f})"
    )
    for idx, (r0, (xs, ys, rs, ts)) in enumerate(traj_data.items()):
        ax_phase.plot(xs, ys, color=colors[idx], linewidth=0.8,
                      alpha=0.8, label=f"r0 = {r0:.1f}")
        ax_phase.plot(xs[0], ys[0], "o", color=colors[idx],
                      markersize=6)
    ax_phase.set_xlabel("x")
    ax_phase.set_ylabel("y")
    ax_phase.set_title("Phase Plane (x-y)", fontweight="bold")
    ax_phase.set_aspect("equal")
    ax_phase.legend(fontsize=7, loc="upper right")
    ax_phase.grid(True, alpha=0.3)
    ax_phase.set_xlim(-2.3, 2.3)
    ax_phase.set_ylim(-2.3, 2.3)

    ax_r = axes[1]
    ax_r.axhline(y=r_star, color="k", linestyle="--",
                 linewidth=1.5, alpha=0.5, label=f"r* = {r_star:.1f}")
    for idx, (r0, (xs, ys, rs, ts)) in enumerate(traj_data.items()):
        ax_r.plot(ts, rs, color=colors[idx], linewidth=1.3,
                  label=f"r0 = {r0:.1f}")
    ax_r.set_xlabel("Time (s)")
    ax_r.set_ylabel("r(t)")
    ax_r.set_title("Amplitude Convergence", fontweight="bold")
    ax_r.legend(fontsize=8)
    ax_r.grid(True, alpha=0.3)

    fig.suptitle(
        "Hopf Oscillator: Convergence to Limit Cycle",
        fontsize=13, fontweight="bold"
    )
    fig.tight_layout()
    return fig

buf = io.BytesIO()
fig = plot_hopf_phase_plane(trajectories, mu)
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close(fig)
`}
/>

<CodeEditor
  initialCode={`import math

# CPG simulation using coupled phase oscillators
# For bipedal walking with 4 oscillators

# Parameters
omega_base = 2 * math.pi * 1.5  # base frequency (1.5 Hz walking)
coupling_strength = 5.0

# Phase offsets (desired relationships)
# 0: left hip, 1: right hip, 2: left knee, 3: right knee
psi = [
    [0, math.pi, math.pi/2, 0],       # from left hip's perspective
    [math.pi, 0, 0, math.pi/2],       # from right hip's perspective
    [-math.pi/2, 0, 0, math.pi],      # from left knee's perspective
    [0, -math.pi/2, math.pi, 0],      # from right knee's perspective
]

# Coupling weights (symmetric network)
w = [
    [0, 3, 2, 0],
    [3, 0, 0, 2],
    [2, 0, 0, 1],
    [0, 2, 1, 0],
]

# Initial phases (random start)
phi = [0.0, 0.5, 1.0, 2.0]

dt = 0.001
sim_time = 3.0
steps = int(sim_time / dt)

# Record history for plotting
record_interval = 10
time_history = []
angle_history = [[], [], [], []]
phase_diff_history = []

print("=== CPG Simulation ===")
print(f"Walking frequency: {omega_base/(2*math.pi):.1f} Hz")
print()
print("Time(s)  L_Hip    R_Hip    L_Knee   R_Knee   Phase_diff(L-R hip)")
print("-" * 65)

for k in range(steps):
    t = k * dt

    # Compute phase derivatives
    dphi = [0.0] * 4
    for i in range(4):
        dphi[i] = omega_base
        for j in range(4):
            dphi[i] += w[i][j] * math.sin(phi[j] - phi[i] - psi[i][j])

    # Update phases
    for i in range(4):
        phi[i] += dphi[i] * dt

    # Record data for plotting
    if k % record_interval == 0:
        time_history.append(t)
        for i in range(4):
            angle_history[i].append(math.sin(phi[i]))
        pd = (phi[1] - phi[0]) % (2 * math.pi)
        if pd > math.pi:
            pd -= 2 * math.pi
        phase_diff_history.append(pd)

    # Print joint angles (sine of phase as proxy)
    if k % 300 == 0:
        angles = [math.sin(phi[i]) for i in range(4)]
        phase_diff = (phi[1] - phi[0]) % (2 * math.pi)
        if phase_diff > math.pi:
            phase_diff -= 2 * math.pi
        print(f"{t:5.2f}    {angles[0]:+6.3f}  {angles[1]:+6.3f}  "
              f"{angles[2]:+6.3f}  {angles[3]:+6.3f}   "
              f"{phase_diff:.3f} ({phase_diff/math.pi:.2f}pi)")

print()
print("Phase difference should converge to pi (anti-phase)")

# --- Plot joint angles and phase convergence ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def plot_cpg_results(time_hist, angle_hist, phase_hist):
    """Plot 4-panel CPG simulation results."""
    fig, axes = plt.subplots(2, 2, figsize=(10, 7))
    labels = ["L_Hip", "R_Hip", "L_Knee", "R_Knee"]
    colors = ["#2563eb", "#dc2626", "#16a34a", "#ea580c"]
    t = np.array(time_hist)

    for idx in range(4):
        ax = axes[idx // 2][idx % 2]
        ax.plot(t, angle_hist[idx], color=colors[idx], linewidth=1.2)
        ax.set_title(labels[idx], fontsize=12, fontweight="bold")
        ax.set_ylabel("sin(phi)")
        ax.set_xlabel("Time (s)")
        ax.set_ylim(-1.3, 1.3)
        ax.grid(True, alpha=0.3)

    fig.suptitle(
        "CPG Joint Angle Trajectories (sin of phase)",
        fontsize=13, fontweight="bold"
    )
    fig.tight_layout()
    return fig

def plot_phase_convergence(time_hist, phase_hist):
    """Plot phase difference convergence to pi."""
    fig, ax = plt.subplots(figsize=(8, 3.5))
    t = np.array(time_hist)
    pd = np.array(phase_hist)
    ax.plot(t, pd / np.pi, color="#7c3aed", linewidth=1.5)
    ax.axhline(y=1.0, color="#dc2626", linestyle="--", alpha=0.7,
               label="Target (pi)")
    ax.set_xlabel("Time (s)")
    ax.set_ylabel("Phase diff (L-R hip) / pi")
    ax.set_title("Phase Difference Convergence", fontweight="bold")
    ax.legend()
    ax.grid(True, alpha=0.3)
    fig.tight_layout()
    return fig

def save_and_print_figure(fig):
    """Encode figure as base64 PNG and print for display."""
    buf = io.BytesIO()
    fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
    buf.seek(0)
    img = base64.b64encode(buf.read()).decode("utf-8")
    print(f"data:image/png;base64,{img}")
    plt.close(fig)

save_and_print_figure(plot_cpg_results(
    time_history, angle_history, phase_diff_history
))
save_and_print_figure(plot_phase_convergence(
    time_history, phase_diff_history
))
`}
/>

## Modulating CPG Parameters

CPG parameters can be modulated to change gait properties:

- **Frequency ($\omega$)**: walking speed
- **Amplitude ($\mu$)**: step size
- **Phase offsets ($\psi$)**: gait pattern (walk, trot, gallop)
- **Coupling weights ($w$)**: inter-joint coordination strength

<CodeEditor
  initialCode={`import math

# Demonstrate CPG frequency modulation
# Speed changes by adjusting omega

speeds = [
    ("Slow walk", 1.0),
    ("Normal walk", 1.5),
    ("Fast walk", 2.0),
    ("Slow run", 2.5),
]

print("=== CPG Frequency Modulation ===")
print()

dt = 0.001
all_waveforms = {}

for name, freq in speeds:
    omega = 2 * math.pi * freq
    amplitude = 0.3 + 0.15 * freq  # larger steps at higher speed

    # Simulate two cycles for visualization
    sim_duration = 2.0
    num_steps = int(sim_duration / dt)
    max_vel = 0
    times = []
    positions = []

    phi = 0.0
    for k in range(num_steps):
        t = k * dt
        phi += omega * dt
        pos = amplitude * math.sin(phi)
        vel = amplitude * omega * math.cos(phi)
        max_vel = max(max_vel, abs(vel))
        times.append(t)
        positions.append(pos)

    period = 1.0 / freq
    print(f"{name} ({freq:.1f} Hz):")
    print(f"  Period: {period:.3f} s")
    print(f"  Amplitude: {amplitude:.2f} rad")
    print(f"  Max angular velocity: {max_vel:.2f} rad/s")
    print()

    all_waveforms[name] = (times, positions, freq, amplitude)

# --- Plot overlaid waveforms ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def plot_frequency_modulation(waveforms):
    """Plot joint angle waveforms at different walking speeds."""
    fig, axes = plt.subplots(1, 2, figsize=(11, 4.5))
    colors = ["#2563eb", "#16a34a", "#ea580c", "#dc2626"]

    ax_wave = axes[0]
    for idx, (name, (ts, ps, freq, amp)) in enumerate(waveforms.items()):
        ax_wave.plot(ts, ps, color=colors[idx], linewidth=1.3,
                     label=f"{name} ({freq:.1f} Hz)")
    ax_wave.set_xlabel("Time (s)")
    ax_wave.set_ylabel("Joint angle (rad)")
    ax_wave.set_title("Joint Angle Waveforms", fontweight="bold")
    ax_wave.legend(fontsize=8)
    ax_wave.grid(True, alpha=0.3)

    ax_amp = axes[1]
    freqs = [v[2] for v in waveforms.values()]
    amps = [v[3] for v in waveforms.values()]
    ax_amp.bar(
        [f"{f:.1f} Hz" for f in freqs], amps,
        color=colors[:len(freqs)], alpha=0.8
    )
    ax_amp.set_xlabel("Walking frequency")
    ax_amp.set_ylabel("Amplitude (rad)")
    ax_amp.set_title("Amplitude vs Frequency", fontweight="bold")
    ax_amp.grid(True, alpha=0.3, axis="y")

    fig.suptitle(
        "CPG Frequency Modulation",
        fontsize=13, fontweight="bold"
    )
    fig.tight_layout()
    return fig

buf = io.BytesIO()
fig = plot_frequency_modulation(all_waveforms)
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close(fig)
`}
/>

## Sensory Feedback Integration

One of the most important features of biological CPGs is their ability to
integrate sensory feedback. Rather than running as pure open-loop oscillators,
real CPGs receive continuous proprioceptive input that modulates their behavior.

**Proprioceptive feedback** (joint angles, angular velocities, foot contact
forces) can modify CPG parameters in real time:

- **Ground contact sensors** trigger phase transitions. For example, when the
  foot touches the ground, the CPG can immediately switch from swing phase to
  stance phase, even if the oscillator has not yet reached that phase naturally.
- **Joint angle feedback** adjusts oscillator amplitude. If a joint cannot
  reach its target angle (e.g., due to an obstacle), the amplitude parameter
  $\mu$ can be reduced to prevent excessive torque.
- **Force feedback** modulates stance duration. Higher ground reaction forces
  (e.g., carrying a heavy load) can slow the stance phase, giving the robot
  more time to transfer weight safely.

This creates a **closed-loop CPG** that adapts to terrain and disturbances.
A practical example: if the foot contacts the ground earlier than expected
(e.g., stepping onto a raised surface), the ground contact sensor advances
the CPG phase to match the actual ground contact timing. Mathematically, this
is implemented as an additive phase correction:

$$
\dot{\phi}_i = \omega_i + \sum_j w_{ij}\sin(\phi_j - \phi_i - \psi_{ij}) + F_{\text{feedback}}(\phi_i, s_i)
$$

where $s_i$ represents the sensory signals and $F_{\text{feedback}}$ is a
function that maps sensor readings to phase corrections.

## Mapping CPG Outputs to Robot Motions

CPG outputs are typically joint angle trajectories or angular velocity commands.
However, for walking robots, these signals need to be mapped to physically
meaningful motions. There are two common approaches:

**Approach 1: CPG generates foot trajectories.** The CPG oscillator outputs
are interpreted as desired foot positions in Cartesian space (e.g., the $x$
component controls the forward swing, the $y$ component controls the lift
height). Inverse kinematics then computes the required joint angles. This
approach provides intuitive control over step length and height.

**Approach 2: CPG directly drives joint angles.** Each oscillator output is
mapped directly to a joint angle command through scaling and offset parameters.
This is simpler but requires careful manual tuning of the mapping parameters
to produce physically meaningful motions.

A key limitation of CPG-based approaches is that they **do not inherently
ensure physical balance**. Unlike ZMP-based or DCM-based methods (Chapters 3
and 5), which explicitly compute dynamically stable trajectories, a CPG
produces rhythmic patterns that may or may not keep the robot balanced. In
practice, CPG controllers are often combined with balance feedback loops or
used as reference trajectory generators for model-based controllers.

## Advantages of CPG Control

1. **Robustness**: inherently stable rhythmic patterns
2. **Adaptability**: smooth transitions between gaits
3. **Low-dimensional**: few parameters control complex motions
4. **Sensory integration**: feedback naturally modulates the rhythm
5. **Distributed**: no central computation bottleneck

### Connections to Other Topics

- **Reinforcement Learning (Chapter 11)**: CPGs are sometimes used as the
  action space for RL policies. Instead of learning raw joint torques (high-
  dimensional), the RL agent learns CPG parameters (low-dimensional), which
  provides a structured representation that is easier to explore and leads to
  smoother motions.
- **Passive Dynamic Walking (Chapter 4)**: Passive walkers exhibit limit-cycle
  behavior, where the walking pattern is an attractor in state space. CPGs
  replicate this limit-cycle structure in a controlled setting, enabling the
  same energy-efficient periodic gaits but with the ability to modulate speed
  and gait parameters.
- **Whole-Body Control (Chapter 8)**: CPG outputs can serve as reference
  trajectories for whole-body controllers. The CPG generates the desired
  rhythmic motion pattern, and the whole-body controller ensures that the
  robot tracks this pattern while satisfying balance and contact constraints.

## References

- A. Ijspeert, "[Central pattern generators for locomotion control in animals and robots: A review](https://doi.org/10.1016/j.neunet.2008.03.014)," *Neural Networks*, 2008.
- L. Righetti and A. Ijspeert, "[Pattern generators with sensory feedback for the control of quadruped locomotion](https://doi.org/10.1109/ROBOT.2008.4543306)," *Proc. IEEE ICRA*, 2008.

<InteractiveDemo title="CPG Oscillator Network">
  <p className="text-sm text-gray-500">
    Interactive CPG network with adjustable coupling coming soon.
  </p>
</InteractiveDemo>
