import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { VirtualConstraintDiagram } from "@/components/diagrams/HZDDiagram";
import { HybridAutomatonDiagram } from "@/components/diagrams/HybridAutomatonDiagram";
import { ZeroDynamicsSurfaceDiagram } from "@/components/diagrams/ZeroDynamicsSurfaceDiagram";
import { VirtualVsPhysicalConstraintDiagram } from "@/components/diagrams/VirtualVsPhysicalConstraintDiagram";

# Hybrid Zero Dynamics

Hybrid Zero Dynamics (HZD) provides a rigorous mathematical framework for
designing provably stable walking gaits. Unlike heuristic approaches, HZD
guarantees orbital stability through carefully designed virtual constraints.

## Why HZD? The Problem with Trajectory Tracking

Traditional walking controllers rely on **time-based trajectory tracking**:
they prescribe that "at time $t = 0.3$ s, the knee should be at 30 degrees."
This works well on flat ground with no disturbances, but has a fundamental flaw.

Imagine the robot is pushed backward mid-step and slows down. A time-based
controller still demands the same knee angle at $t = 0.3$ s, even though the
robot has not progressed far enough in its step. The result: the commanded
trajectory no longer matches the physical state of the robot, often leading
to a fall.

HZD takes a fundamentally different approach: instead of parameterizing
trajectories by time, it parameterizes them by a **phase variable**
$\theta(\mathbf{q})$, which measures how far the robot has progressed
through the current step. If the robot is pushed and slows down, the phase
progresses more slowly, and the desired joint trajectory automatically
slows down with it.

This **phase-based parameterization** gives HZD inherent robustness to
timing perturbations, which is one of its most important practical
advantages.

## Virtual Constraints

Virtual constraints are holonomic constraints enforced through feedback
control rather than physical mechanisms. They parameterize joint motions
as functions of a single **phase variable** $\theta(\mathbf{q})$:

$$
y = h(\mathbf{q}) - h_d(\theta(\mathbf{q}))
$$

where $h(\mathbf{q})$ selects the controlled outputs and $h_d(\theta)$
defines the desired output as a function of the phase variable.

<VirtualConstraintDiagram />

<VirtualVsPhysicalConstraintDiagram />

### Phase Variable

The phase variable $\theta(\mathbf{q})$ must be:
- **Monotonically increasing** during the step (acts as a clock)
- **Configuration dependent** (not time-based, making the gait robust)

A common choice: the angle of the stance leg (hip angle relative to vertical).

### Bezier Polynomial Parameterization

The desired outputs are typically parameterized using Bezier polynomials:

$$
h_d(\theta) = \sum_{k=0}^{M} \alpha_k \binom{M}{k} s^k (1-s)^{M-k}
$$

where $s = \frac{\theta - \theta^+}{\theta^- - \theta^+} \in [0, 1]$
normalizes the phase, and $\alpha_k$ are the Bezier coefficients to be optimized.

### Why Bezier Polynomials?

Bezier polynomials are chosen over other possible basis functions (Fourier
series, cubic splines, etc.) because of several useful properties:

1. **Smoothness**: Bezier curves are $C^\infty$ continuous, ensuring that the
   resulting joint velocities and accelerations are smooth. This is critical
   for avoiding torque spikes on real hardware.
2. **Convex hull property**: the curve is guaranteed to stay within the convex
   hull of its control points $\alpha_k$. This makes it easy to enforce bounds
   on joint angles during optimization.
3. **Simple derivatives**: the derivative of an $M$-th order Bezier curve is
   an $(M-1)$-th order Bezier curve with coefficients
   $M(\alpha_{k+1} - \alpha_k)$. This simplifies analytical velocity and
   acceleration computation.
4. **Endpoint interpolation**: $h_d(s=0) = \alpha_0$ and
   $h_d(s=1) = \alpha_M$ exactly, giving direct control over the start
   and end values of the trajectory.

## Hybrid System Model

Walking is modeled as a **hybrid system** that alternates between continuous
dynamics and discrete events. The following diagram illustrates this cycle:

<HybridAutomatonDiagram />

### Continuous Phase (Swing)

During the swing phase, the robot is a multi-body system governed by
the manipulator equation:

$$
M(\mathbf{q})\ddot{\mathbf{q}} + \mathbf{h}(\mathbf{q}, \dot{\mathbf{q}}) = B\mathbf{u}
$$

where $M(\mathbf{q})$ is the mass-inertia matrix, $\mathbf{h}$ contains
Coriolis, centrifugal, and gravity terms, $B$ is the input mapping matrix,
and $\mathbf{u}$ is the vector of joint torques. In state-space form:

$$
\dot{\mathbf{x}} = f(\mathbf{x}) + g(\mathbf{x})\mathbf{u}
$$

where $\mathbf{x} = [\mathbf{q}^T, \dot{\mathbf{q}}^T]^T$ is the full state.

Note that bipedal walkers are **underactuated**: the stance foot has no
motor, so $B$ has fewer columns than $\mathbf{q}$ has rows.

### Discrete Phase (Impact)

At heel strike (when the switching surface $S$ is reached):

$$
\mathbf{x}^+ = \Delta(\mathbf{x}^-)
$$

### Impact Map and Leg Relabeling

The impact map $\Delta$ captures two simultaneous effects:

**Velocity jump.** The ground exerts an impulsive force at the contact
point, causing an instantaneous change in joint velocities. Angular
momentum about the new contact point is conserved because the impulsive
ground reaction force passes through it. This yields:

$$
\dot{\mathbf{q}}^+ = H_{\text{impact}}(\mathbf{q}^-) \, \dot{\mathbf{q}}^-
$$

The matrix $H_{\text{impact}}$ depends only on the configuration at impact
(not on velocities), so the velocity map is linear in $\dot{\mathbf{q}}^-$.

**Leg relabeling.** The swing leg becomes the new stance leg and vice
versa. The joint coordinates are reindexed: what was $q_{\text{swing}}$
becomes $q_{\text{stance}}$, and what was $q_{\text{stance}}$ becomes
$q_{\text{swing}}$. This relabeling is represented by a permutation
matrix $R$:

$$
\mathbf{q}^+ = R \, \mathbf{q}^-
$$

## Zero Dynamics

When the virtual constraints are perfectly enforced ($y = 0, \dot{y} = 0$),
the system evolves on a lower-dimensional **zero dynamics surface**.

### Deriving the Zero Dynamics

To understand how the zero dynamics arise, consider the control design
step by step.

**Step 1: Define the output.** We define virtual constraint outputs:

$$
y = h_d(\mathbf{q}) - h_a(\mathbf{q}, s)
$$

where $h_d(\mathbf{q})$ selects the actual joint values (controlled outputs)
and $h_a(\mathbf{q}, s)$ is the desired trajectory parameterized by the
phase variable $s = s(\theta(\mathbf{q}))$.

**Step 2: Input-output linearization.** Differentiate $y$ twice with respect
to time. To express these derivatives compactly, we use **Lie derivative**
notation from nonlinear control theory.

**Lie derivative definition.** For a scalar function $h(\mathbf{x})$ and a
vector field $f(\mathbf{x})$, the Lie derivative of $h$ along $f$ is
defined as the directional derivative of $h$ in the direction of $f$:

$$
L_f h(\mathbf{x}) = \frac{\partial h}{\partial \mathbf{x}} f(\mathbf{x}) = \nabla h \cdot f
$$

Intuitively, $L_f h$ measures **how fast $h$ changes as the state flows
along $f$**. If $\dot{\mathbf{x}} = f(\mathbf{x})$, then
$\frac{d}{dt}h(\mathbf{x}) = L_f h(\mathbf{x})$.

Higher-order Lie derivatives are obtained by repeated application:

$$
L_f^2 h = L_f(L_f h) = \frac{\partial (L_f h)}{\partial \mathbf{x}} f(\mathbf{x})
$$

For control-affine systems $\dot{\mathbf{x}} = f(\mathbf{x}) + g(\mathbf{x})\mathbf{u}$,
the mixed Lie derivative $L_g L_f h$ captures the influence of the
control input on the second time derivative of $h$.

Using this notation, because the system is control-affine, the second
derivative of $y$ produces a term involving $\mathbf{u}$:

$$
\ddot{y} = L_f^2 y + L_g L_f y \cdot \mathbf{u}
$$

We choose the control input $\mathbf{u}$ so that the output obeys:

$$
\ddot{y} = -K_p y - K_d \dot{y}
$$

This is a PD-like control law that drives the output $y$ to zero
exponentially. With appropriate gains $K_p, K_d > 0$, we get
$y(t) \to 0$ and $\dot{y}(t) \to 0$.

**Step 3: The zero dynamics surface.** When $y = 0$ and $\dot{y} = 0$
are exactly satisfied, the virtual constraints are perfectly enforced.
The system is then confined to the **zero dynamics surface** $Z$:

$$
Z = \{(\mathbf{q}, \dot{\mathbf{q}}) \mid y = 0, \dot{y} = 0\}
$$

<ZeroDynamicsSurfaceDiagram />

**Step 4: Dimension reduction.** On this surface, the original $n$-DOF
system reduces to a lower-dimensional system. For example, a 2-link
planar biped has 2 DOF. With 1 virtual constraint, the zero dynamics
are $2 - 1 = 1$ DOF, described by:

$$
\ddot{\theta} = \kappa(\theta, \dot{\theta})
$$

This is a second-order system that completely determines the walking behavior
when virtual constraints are satisfied.

## Stability Analysis

The gait is stable if the **hybrid zero dynamics** has a stable periodic orbit.

### Poincare Map on Zero Dynamics

Since the zero dynamics are 2D (with states $\theta, \dot{\theta}$), the
Poincare map reduces to a scalar map:

$$
\dot{\theta}_{n+1}^+ = \rho(\dot{\theta}_n^+)
$$

The fixed point $\dot{\theta}^*$ satisfying $\dot{\theta}^* = \rho(\dot{\theta}^*)$
is stable if $|\rho'(\dot{\theta}^*)| < 1$.

<CodeEditor
  initialCode={`import math

def evaluate_bezier(alpha, s):
    """Evaluate Bezier polynomial at normalized phase s."""
    M = len(alpha) - 1
    result = 0.0
    for k in range(M + 1):
        binom = (math.factorial(M)
                 // (math.factorial(k)
                     * math.factorial(M - k)))
        result += alpha[k] * binom * s**k * (1-s)**(M-k)
    return result

def evaluate_bezier_derivative(alpha, s):
    """Evaluate derivative of Bezier polynomial."""
    M = len(alpha) - 1
    if M == 0:
        return 0.0
    d_alpha = [M*(alpha[k+1]-alpha[k]) for k in range(M)]
    return evaluate_bezier(d_alpha, s)

alpha_hip = [0.3, 0.25, 0.1, -0.1, -0.25, -0.3]
theta_plus = -0.2
theta_minus = 0.2

print("=== Virtual Constraint (Hip Angle) ===")
print(f"Bezier order: {len(alpha_hip) - 1}")
print(f"Coefficients: {alpha_hip}")
print(f"Phase range: [{theta_plus:.2f}, {theta_minus:.2f}]")
print()
print("Phase(s)  Desired_hip(deg)  Velocity(deg/s)")
print("-" * 48)

for i in range(11):
    s = i / 10.0
    hip_d = evaluate_bezier(alpha_hip, s)
    hip_v = evaluate_bezier_derivative(alpha_hip, s)
    hip_v /= (theta_minus - theta_plus)
    print(f"  {s:.1f}      {math.degrees(hip_d):8.2f}"
          f"         {math.degrees(hip_v):8.2f}")

print()
start_deg = math.degrees(evaluate_bezier(alpha_hip, 0))
end_deg = math.degrees(evaluate_bezier(alpha_hip, 1))
print("The hip angle smoothly transitions from")
print(f"  {start_deg:.1f} deg (start)")
print(f"  to {end_deg:.1f} deg (end)")

# --- Plot Bezier curve with control points and velocity ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

s_vals = np.linspace(0, 1, 200)
curve_vals = [evaluate_bezier(alpha_hip, s) for s in s_vals]
deriv_vals = [
    evaluate_bezier_derivative(alpha_hip, s)
    / (theta_minus - theta_plus) for s in s_vals]
curve_deg = np.degrees(curve_vals)
deriv_deg = np.degrees(deriv_vals)
alpha_deg = [math.degrees(a) for a in alpha_hip]

fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(7, 6))
M = len(alpha_hip) - 1
ctrl_s = [k / M for k in range(M + 1)]
ax1.plot(s_vals, curve_deg, "b-", linewidth=2,
         label="Bezier curve")
ax1.plot(ctrl_s, alpha_deg, "rs--", markersize=8,
         linewidth=1, label="Control points")
ax1.fill_between(
    s_vals, min(alpha_deg), max(alpha_deg),
    alpha=0.1, color="red", label="Convex hull bound")
ax1.set_xlabel("Normalized phase s")
ax1.set_ylabel("Hip angle (deg)")
ax1.set_title("Bezier Virtual Constraint with Control Points")
ax1.legend(fontsize=8)
ax1.grid(True, alpha=0.3)

ax2.plot(s_vals, deriv_deg, "g-", linewidth=2)
ax2.axhline(y=0, color="k", linestyle="--", linewidth=0.5)
ax2.set_xlabel("Normalized phase s")
ax2.set_ylabel("dh/ds (deg/rad)")
ax2.set_title("Velocity Profile (dh/ds)")
ax2.grid(True, alpha=0.3)

fig.tight_layout()
buf = io.BytesIO()
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()
`}
/>

## Gait Optimization

Finding good Bezier coefficients $\alpha$ requires optimization:

$$
\min_{\alpha} J(\alpha) \quad \text{s.t. stability and physical constraints}
$$

The cost $J$ typically includes:
- Walking speed
- Energy consumption (torque squared)
- Ground clearance
- Impact forces

Constraints include:
- Fixed-point stability: $|\rho'(\dot{\theta}^*)| < 1$
- Foot clearance: swing foot stays above ground
- Friction cone: no slipping
- Torque limits

<CodeEditor
  initialCode={`import math

def compute_poincare_map(theta_dot_plus,
                         step_length=0.3):
    """Simplified return map for zero dynamics."""
    g = 9.81
    l = 0.8
    energy_in = theta_dot_plus**2
    half_a = math.asin(step_length / (2 * l))
    impact_ratio = math.cos(2 * half_a)
    energy_out = energy_in * impact_ratio**2
    energy_out += 2*g/l * (1 - math.cos(half_a))
    if energy_out < 0:
        return 0.0
    return math.sqrt(energy_out)

print("=== Poincare Map Analysis ===")
print()
theta_dot = 1.5
print("Iter  theta_dot_in  theta_dot_out  Converged?")
print("-" * 52)

fixed_point = None
for i in range(15):
    td_out = compute_poincare_map(theta_dot)
    err = abs(td_out - theta_dot)
    conv = "YES" if err < 0.001 else ""
    print(f"  {i:2d}      {theta_dot:8.4f}"
          f"      {td_out:8.4f}       {conv}")
    if err < 0.001:
        fixed_point = theta_dot
        print(f"\\nFixed point: theta_dot* = "
              f"{theta_dot:.4f} rad/s")
        break
    theta_dot = td_out

eps = 0.001
rho_prime = (
    compute_poincare_map(theta_dot + eps)
    - compute_poincare_map(theta_dot - eps)
) / (2 * eps)
print(f"Poincare map derivative: |rho'| = "
      f"{abs(rho_prime):.4f}")
if abs(rho_prime) < 1:
    print("Gait is LOCALLY STABLE")
else:
    print("Gait is UNSTABLE")

# --- Plot return map, fixed point, and cobweb ---
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

def plot_poincare_cobweb(fp, rho_d):
    """Plot return map P(x), y=x, and cobweb."""
    xr = np.linspace(0.5, 3.0, 200)
    pv = [compute_poincare_map(x) for x in xr]
    fig, ax = plt.subplots(figsize=(7, 6))
    ax.plot(xr, pv, "b-", linewidth=2,
            label="Return map P(x)")
    ax.plot(xr, xr, "k--", linewidth=1,
            label="y = x (identity)")
    ax.plot(fp, fp, "ro", markersize=12, zorder=5,
            label=f"Fixed point = {fp:.3f}")
    xc = 1.5
    cx, cy = [xc], [0]
    for _ in range(12):
        yn = compute_poincare_map(xc)
        cx.extend([xc, yn])
        cy.extend([yn, yn])
        xc = yn
    ax.plot(cx, cy, "m-", linewidth=0.8,
            alpha=0.7, label="Cobweb iteration")
    ax.set_xlabel("theta_dot_n (rad/s)")
    ax.set_ylabel("theta_dot_n+1 (rad/s)")
    ax.set_title("Poincare Return Map  |rho'| = "
                 + f"{abs(rho_d):.4f}")
    ax.legend(fontsize=8)
    ax.grid(True, alpha=0.3)
    ax.set_aspect("equal")
    fig.tight_layout()
    return fig

if fixed_point is not None:
    fig = plot_poincare_cobweb(fixed_point, rho_prime)
    buf = io.BytesIO()
    fig.savefig(buf, format="png", dpi=100,
                bbox_inches="tight")
    buf.seek(0)
    img = base64.b64encode(buf.read()).decode("utf-8")
    print(f"data:image/png;base64,{img}")
    plt.close()
`}
/>

## Simulation: Zero Dynamics Phase Portrait

The zero dynamics describe the 1-DOF system that remains after virtual
constraints are enforced. Its phase portrait reveals the structure of
the walking gait: stable limit cycles appear as closed orbits that
attract neighboring trajectories.

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use("agg")
import matplotlib.pyplot as plt
import numpy as np
import io, base64

g = 9.81
l = 0.8
m_h = 5.0
m_l = 1.0
slope = 0.05

def compute_zd_accel(theta, dtheta):
    """Compute acceleration on zero dynamics surface."""
    grav = (m_h+m_l)*g*math.sin(theta-slope)/l
    damp = 0.05 * dtheta
    return (-grav - damp) / (m_h + m_l)

def simulate_zd(th0, dth0, dt=0.001, n_max=5000):
    """Integrate zero dynamics from initial condition."""
    ths, dths = [th0], [dth0]
    th, dth = th0, dth0
    for _ in range(n_max):
        ddth = compute_zd_accel(th, dth)
        dth += ddth * dt
        th += dth * dt
        ths.append(th)
        dths.append(dth)
        if th >= 0.2 or dth < 0:
            break
    return ths, dths

def apply_impact(dtheta, step_length=0.3):
    """Apply impact map and leg relabeling."""
    ha = math.asin(step_length / (2 * l))
    return -0.2, dtheta * abs(math.cos(2 * ha))

ics = [
    (-0.2, 0.8, "tab:blue"),
    (-0.2, 1.2, "tab:orange"),
    (-0.2, 1.6, "tab:green"),
    (-0.2, 2.0, "tab:red"),
    (-0.2, 0.5, "tab:purple"),
]

fig, ax = plt.subplots(figsize=(7, 6))
for th0, dth0, color in ics:
    a_th, a_dth = [], []
    t_ic, d_ic = th0, dth0
    for _ in range(8):
        tl, dl = simulate_zd(t_ic, d_ic)
        a_th.extend(tl)
        a_dth.extend(dl)
        if dl[-1] <= 0:
            break
        t_ic, d_ic = apply_impact(dl[-1])
    ax.plot(a_th, a_dth, color=color,
            linewidth=1.2, alpha=0.8,
            label=f"dtheta0 = {dth0:.1f}")
    ax.plot(a_th[0], a_dth[0], "o",
            color=color, markersize=6)

ax.set_xlabel("theta (rad)")
ax.set_ylabel("dtheta/dt (rad/s)")
ax.set_title("Zero Dynamics Phase Portrait")
ax.legend(fontsize=8, loc="upper left")
ax.grid(True, alpha=0.3)
ax.axvline(x=0.2, color="gray", linestyle=":",
           linewidth=1)
fig.tight_layout()
buf = io.BytesIO()
fig.savefig(buf, format="png", dpi=100, bbox_inches="tight")
buf.seek(0)
img = base64.b64encode(buf.read()).decode("utf-8")
print(f"data:image/png;base64,{img}")
plt.close()

print()
print("=== Zero Dynamics Phase Portrait ===")
print("Each trajectory starts from theta = -0.2 rad")
print("with different initial angular velocities.")
print()
print("Trajectories that are too slow stall before")
print("reaching the impact surface (theta = 0.2).")
print("Trajectories near the stable gait converge")
print("to a limit cycle across multiple steps.")
`}
/>

## Advantages of HZD

1. **Provable stability**: rigorous Poincare analysis guarantees stability
2. **Time-independent**: phase-based parameterization handles speed variations
3. **Low-dimensional analysis**: zero dynamics reduce the stability problem
4. **Optimization-friendly**: Bezier coefficients are smooth optimization variables
5. **Hardware validated**: successfully demonstrated on Cassie, Digit, MABEL

## Connections to Other Chapters

- **Passive Walking (Chapter 4)**: HZD inherits the Poincare map analysis
  framework from passive walking theory. The stability of an HZD walking
  gait is assessed by computing the eigenvalues of the linearized Poincare
  return map, exactly as done for passive walkers on a slope.
- **Reinforcement Learning (Chapter 11)**: HZD virtual constraints can serve
  as the structure for RL policy output. Instead of learning raw joint
  torques, an RL agent can learn Bezier coefficients $\alpha_k$ that define
  the virtual constraints. This dramatically reduces the search space and
  often leads to faster, more robust learning.

## References

- E. Westervelt et al., "[Hybrid zero dynamics of planar biped walkers](https://doi.org/10.1109/TAC.2003.814636)," *IEEE Trans. Automatic Control*, 2003.
- A. Ames et al., "[Human-Inspired Control of Bipedal Walking Robots](https://doi.org/10.1109/TAC.2014.2299342)," *IEEE Trans. Automatic Control*, 2014.
- J. Grizzle et al., "[MABEL, A New Robotic Bipedal Walker and Runner](https://doi.org/10.1109/ACC.2009.5160550)," *Proc. ACC*, 2009.

<InteractiveDemo title="Virtual Constraint Design">
  <p className="text-sm text-gray-500">
    Interactive virtual constraint design with Bezier polynomial editor coming soon.
  </p>
</InteractiveDemo>
