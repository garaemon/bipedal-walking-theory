import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { PassiveWalkerDiagram, PoincareDiagram } from "@/components/diagrams/PassiveWalkerDiagram";
import { PassiveWalkerAnimationDiagram } from "@/components/diagrams/PassiveWalkerAnimationDiagram";

# Passive Dynamic Walking

Passive dynamic walking demonstrates that bipedal locomotion does not necessarily
require active control. Pioneered by Tad McGeer in 1990, passive walkers exploit
gravity and mechanical dynamics to walk down shallow slopes with no motors or
controllers.

## McGeer's Passive Walker

McGeer showed that a simple two-legged mechanism can walk stably down a slope
using only gravity. The key insight: **walking is fundamentally a process of
controlled falling**.

A minimal passive walker consists of:
- Two rigid legs connected at a hip joint
- Point feet (or curved feet for stability)
- A shallow slope providing gravitational energy input

<PassiveWalkerDiagram />

<PassiveWalkerAnimationDiagram />

## Hybrid Dynamical System

Passive walking is a **hybrid dynamical system** -- it combines:

1. **Continuous dynamics** (swing phase): governed by differential equations
1. **Discrete events** (heel strike): instantaneous velocity changes

### Swing Phase Dynamics

For a planar compass-gait walker with leg length $l$, hip mass $M$,
and foot mass $m$, the swing phase dynamics on a slope of angle $\gamma$ are:

$$
M_{\theta}(\theta)\ddot{\theta} + C_{\theta}(\theta, \dot{\theta})\dot{\theta} + G_{\theta}(\theta) = 0
$$

where $\theta = [\theta_{st}, \theta_{sw}]^T$ are the stance and swing leg angles.

For the simplest walker (point masses at hip and feet):

$$
\ddot{\theta}_{st} = \sin(\theta_{st} - \gamma)
$$

$$
\ddot{\theta}_{sw} = \ddot{\theta}_{st} + \dot{\theta}_{st}^2 \sin(\theta_{sw}) - \cos(\theta_{st} - \gamma)\sin(\theta_{sw})
$$

> **Note on normalization:** The equations above are normalized by setting
> $g/l = 1$ and $m_H/m = 1$. This means time is measured in units of
> $\sqrt{l/g}$ and angles are in radians. Normalization is useful because
> it reduces the number of free parameters, letting us study the dynamics
> in terms of only the slope angle $\gamma$ and the mass ratio.

### Heel Strike (Impact Map)

At heel strike, angular momentum is conserved about the impact point.
This gives a discrete map from pre-impact to post-impact velocities:

$$
\dot{\theta}^+ = H(\theta^-)\dot{\theta}^-
$$

where $H$ is the impact transition matrix:

$$
H = \begin{bmatrix} \cos(2\alpha) & 0 \\ \cos(2\alpha)(1 - \cos(2\alpha)) & 0 \end{bmatrix}
$$

for a symmetric walker with inter-leg angle $2\alpha$ at impact.

### Deriving the Impact Transition Matrix

The impact transition matrix $H$ is derived from the **angular momentum
conservation principle**. Here is the physical reasoning step by step:

1. **Just before impact**, the swing leg touches the ground. This creates an
   impulsive ground reaction force at the new contact point.
1. **The impulsive force acts through the new contact point**, so it produces
   zero moment about that point. Therefore, **angular momentum about the new
   contact point is conserved** across the impact instant.
1. We write angular momentum before and after impact about the new stance foot:

$$
H_{after}(\theta^-) \dot{\theta}^+ = H_{before}(\theta^-) \dot{\theta}^-
$$

Solving for the post-impact velocities gives $\dot{\theta}^+ = H_{after}^{-1} H_{before} \dot{\theta}^-$.
For the simplest compass-gait walker with point masses, the inertia matrices
simplify, and the product $H_{after}^{-1} H_{before}$ yields the transition
matrix $H$ shown above.

The key physical consequence: **heel-strike always reduces the kinetic energy**
because the velocity component perpendicular to the new stance leg is
instantaneously lost (analogous to a perfectly inelastic collision).

## Energy Balance in Passive Walking

In steady-state walking on a slope, an elegant energy balance holds:
the energy gained from descending the slope **exactly equals** the energy
lost at each heel-strike collision.

**Energy gained per step** from gravity:

$$
\Delta E_{gain} = m g \cdot d_{step} \cdot \sin(\gamma)
$$

where $d_{step}$ is the step length and $\gamma$ is the slope angle.

**Energy lost at impact** from the velocity jump:

$$
\Delta E_{loss} = \frac{1}{2} m \left( v_{before}^2 - v_{after}^2 \right)
$$

For a periodic gait to exist, $\Delta E_{gain} = \Delta E_{loss}$.
This condition uniquely determines the steady-state walking speed for a
given slope angle. A steeper slope provides more energy, leading to faster
walking with larger collision losses at each impact.

## Limit Cycles

A stable passive gait corresponds to a **limit cycle** -- a periodic orbit in
state space that nearby trajectories converge to.

### Phase Portrait

The state of the walker at heel strike can be described by the stance leg angle
$\theta$ and angular velocity $\dot{\theta}$. A stable walking gait appears as
a closed orbit in the $(\theta, \dot{\theta})$ phase plane.

<PoincareDiagram />

## Poincare Map Analysis

To analyze stability, we use a **Poincare map** $P$: a discrete-time map from
one heel strike to the next.

$$
\mathbf{x}_{n+1} = P(\mathbf{x}_n)
$$

where $\mathbf{x}_n$ is the state at the $n$-th heel strike.

### Fixed Point and Stability

A periodic gait is a **fixed point** $\mathbf{x}^*$ of the Poincare map:

$$
\mathbf{x}^* = P(\mathbf{x}^*)
$$

The gait is locally stable if all eigenvalues of the Jacobian
$\frac{\partial P}{\partial \mathbf{x}}\big|_{\mathbf{x}^*}$ have magnitude less than 1.

## Python Simulation: Simplest Walker

<CodeEditor
  initialCode={`import math

# Simplest passive walker simulation
# (rimless wheel model as a starting point)

# Parameters
g = 9.81       # gravity (m/s^2)
l = 1.0        # leg length (m)
gamma = 0.05   # slope angle (radians, about 3 degrees)
n_spokes = 5   # number of legs (rimless wheel)
alpha = math.pi / n_spokes  # half inter-leg angle

print("=== Rimless Wheel on Slope ===")
print(f"Slope angle: {math.degrees(gamma):.1f} degrees")
print(f"Number of spokes: {n_spokes}")
print(f"Half inter-leg angle: {math.degrees(alpha):.1f} degrees")
print()

# Heel strike collision: angular velocity ratio
# omega_plus / omega_minus = cos(2*alpha)
collision_ratio = math.cos(2 * alpha)
print(f"Collision velocity ratio: {collision_ratio:.4f}")

# Energy balance for steady-state rolling
# Energy gained from gravity per step = Energy lost at collision
# Steady-state angular velocity before collision:
omega_minus_sq = 2 * g / l * (1 - math.cos(2 * alpha * math.sin(gamma) / math.sin(2 * alpha)))

# Simplified for small gamma:
omega_steady = math.sqrt(2 * g * math.sin(gamma) * math.tan(alpha) / (l * (1 - collision_ratio**2)))

print(f"Steady-state angular velocity: {omega_steady:.4f} rad/s")
print()

# Simulate multiple steps
omega = omega_steady * 0.8  # start slightly slower
print("Step  omega_before  omega_after   Steady?")
print("-" * 48)

for step in range(10):
    # Swing phase: energy conservation on slope
    # omega_end^2 = omega_start^2 + 2*(g/l)*(cos(theta_end) - cos(theta_start))
    # For small angles, gain from slope:
    energy_gain = 2 * (g / l) * math.sin(gamma) * math.sin(2 * alpha)
    omega_before_strike = math.sqrt(omega**2 + energy_gain)

    # Heel strike
    omega_after_strike = collision_ratio * omega_before_strike

    converged = "~" if abs(omega_after_strike - omega_steady * collision_ratio) < 0.01 else " "
    print(f"  {step:2d}     {omega_before_strike:8.4f}      {omega_after_strike:8.4f}     {converged}")

    omega = omega_after_strike

# Plot convergence of angular velocity
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

omega_plot = omega_steady * 0.8
steps = list(range(15))
omega_before_list = []
omega_after_list = []

for s in steps:
    energy_gain_plot = 2 * (g / l) * math.sin(gamma) * math.sin(2 * alpha)
    omega_before_plot = math.sqrt(omega_plot**2 + energy_gain_plot)
    omega_after_plot = collision_ratio * omega_before_plot
    omega_before_list.append(omega_before_plot)
    omega_after_list.append(omega_after_plot)
    omega_plot = omega_after_plot

fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(steps, omega_before_list, 'bo-', label='Before heel strike')
ax.plot(steps, omega_after_list, 'rs-', label='After heel strike')
ax.axhline(y=omega_steady, color='green', linestyle='--',
           label=f'Steady state = {omega_steady:.4f}')
ax.axhline(y=omega_steady * collision_ratio, color='orange',
           linestyle='--',
           label=f'Steady after strike = '
                 f'{omega_steady * collision_ratio:.4f}')
ax.set_xlabel('Step number')
ax.set_ylabel('Angular velocity (rad/s)')
ax.set_title('Rimless Wheel: Convergence of Angular Velocity')
ax.legend(fontsize=8)
ax.grid(True, alpha=0.3)
plt.tight_layout()

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## Energy Efficiency

Passive walkers are remarkably energy-efficient compared to actively controlled
robots. The **cost of transport** (CoT) measures energy efficiency:

$$
CoT = \frac{E_{input}}{m g d}
$$

where $E_{input}$ is energy consumed, $m$ is mass, $g$ is gravity, and $d$ is
distance traveled.

| Walker type | Cost of Transport |
|-------------|------------------|
| Passive walker | ~0.05 |
| Human walking | ~0.20 |
| Honda ASIMO | ~3.2 |
| Boston Dynamics Atlas | ~2.0 |

Passive walkers achieve near-human efficiency because they exploit natural
dynamics rather than fighting them.

## Bifurcation and Chaos

As slope angle $\gamma$ increases, the passive walker exhibits **period-doubling
bifurcation** -- a classic route to chaos in nonlinear dynamical systems.

**What this means physically:**

1. **Small $\gamma$**: The walker takes identical steps every cycle (period-1 gait).
   Each step has the same step length and speed.
1. **Moderate $\gamma$**: The walker begins alternating between two different step
   patterns -- one long step followed by one short step (period-2 gait).
   Further increase leads to period-4: four distinct steps before repeating.
1. **Large $\gamma$**: The walker takes irregular, non-repeating steps (chaotic gait).
   Eventually, the walker accumulates too much energy and falls.

The actual compass-gait walker shows exactly this period-doubling cascade,
as demonstrated numerically by Goswami et al. (1998). The code below
illustrates the concept using the **logistic map as an analogy**. The logistic
map $x_{n+1} = r x_n (1 - x_n)$ is NOT the walker's Poincare map, but it
exhibits the same qualitative bifurcation structure, making it a useful
pedagogical tool.

<CodeEditor
  initialCode={`import math

# Demonstrate period-doubling using the logistic map as an ANALOGY.
# The actual compass-gait Poincare map shows the same bifurcation
# structure, but requires numerical ODE integration to compute.

print("=== Bifurcation Behavior (Logistic Map Analogy) ===")
print()
print("As slope increases, the walker gait transitions:")
print("  Period-1 -> Period-2 -> Period-4 -> Chaos -> Falling")
print()

# Logistic map: x_{n+1} = r * x_n * (1 - x_n)
# Parameter r plays the role of slope angle gamma
slopes = [
    (0.02, 2.8, "Period-1: every step is identical"),
    (0.04, 3.2, "Period-2: alternating long/short steps"),
    (0.06, 3.5, "Period-4: four-step repeating pattern"),
    (0.08, 3.9, "Chaos: irregular, non-repeating steps"),
]

for gamma_val, r, label in slopes:
    x = 0.5
    # Run 50 iterations to reach the attractor
    for _ in range(50):
        x = r * x * (1 - x)
    # Collect next 8 iterations
    values = []
    for _ in range(8):
        x = r * x * (1 - x)
        values.append(x)

    unique = sorted(set(round(v, 4) for v in values))
    print(f"Slope ~{gamma_val:.2f} rad (r={r}): {label}")
    print(f"  Distinct states: {len(unique)}")
    print(f"  Values: {[f'{v:.4f}' for v in unique[:4]]}")
    print()

# Plot bifurcation diagram
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

n_r = 2000
n_discard = 500
n_plot = 200
r_min, r_max = 2.5, 4.0
r_values = np.linspace(r_min, r_max, n_r)
r_plot = []
x_plot = []

for r_val in r_values:
    x = 0.5
    for _ in range(n_discard):
        x = r_val * x * (1.0 - x)
    for _ in range(n_plot):
        x = r_val * x * (1.0 - x)
        r_plot.append(r_val)
        x_plot.append(x)

fig, ax = plt.subplots(figsize=(10, 6))
ax.scatter(r_plot, x_plot, s=0.02, c='black', alpha=0.5)
ax.set_xlabel('Parameter r (analogous to slope angle)')
ax.set_ylabel('Steady-state values')
ax.set_title('Bifurcation Diagram (Logistic Map)')
ax.set_xlim(r_min, r_max)
ax.set_ylim(0, 1)
ax.grid(True, alpha=0.3)
plt.tight_layout()

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>

## Simulation: Compass Gait Phase Portrait

The following simulation integrates a simplified compass-gait swing leg
dynamics using the 4th-order Runge-Kutta method. Multiple trajectories
from different initial conditions are plotted in the phase plane
($\theta_{sw}$, $\dot{\theta}_{sw}$), showing how orbits converge toward
a limit cycle or diverge.

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Simplified swing leg dynamics for compass gait walker
# theta_sw'' = -sin(theta_sw) + gamma * cos(theta_sw)
# State: [theta_sw, theta_sw_dot]

gamma = 0.05  # slope angle (rad)

def swing_deriv(state):
    theta, theta_dot = state
    theta_ddot = -math.sin(theta) + gamma * math.cos(theta)
    return [theta_dot, theta_ddot]

def rk4_step(state, dt):
    k1 = swing_deriv(state)
    s2 = [state[0] + 0.5*dt*k1[0], state[1] + 0.5*dt*k1[1]]
    k2 = swing_deriv(s2)
    s3 = [state[0] + 0.5*dt*k2[0], state[1] + 0.5*dt*k2[1]]
    k3 = swing_deriv(s3)
    s4 = [state[0] + dt*k3[0], state[1] + dt*k3[1]]
    k4 = swing_deriv(s4)
    new_theta = state[0] + (dt/6)*(k1[0]+2*k2[0]+2*k3[0]+k4[0])
    new_tdot = state[1] + (dt/6)*(k1[1]+2*k2[1]+2*k3[1]+k4[1])
    return [new_theta, new_tdot]

def simulate_trajectory(theta0, tdot0, dt, n_steps):
    thetas = [theta0]
    tdots = [tdot0]
    state = [theta0, tdot0]
    for _ in range(n_steps):
        state = rk4_step(state, dt)
        thetas.append(state[0])
        tdots.append(state[1])
    return thetas, tdots

# Initial conditions: varying angle and velocity
initial_conditions = [
    (0.1, 0.0, 'blue'),
    (0.2, 0.0, 'red'),
    (0.3, 0.0, 'green'),
    (-0.1, 0.5, 'purple'),
    (-0.2, -0.3, 'orange'),
    (0.15, -0.5, 'cyan'),
    (0.05, 0.8, 'brown'),
    (-0.15, 0.6, 'magenta'),
]

dt = 0.005
n_steps = 3000

fig, ax = plt.subplots(figsize=(8, 6))

for theta0, tdot0, color in initial_conditions:
    thetas, tdots = simulate_trajectory(theta0, tdot0, dt, n_steps)
    ax.plot(thetas, tdots, color=color, alpha=0.6, linewidth=0.8)
    ax.plot(thetas[0], tdots[0], 'o', color=color, markersize=5)

ax.set_xlabel('Swing leg angle (rad)')
ax.set_ylabel('Swing leg angular velocity (rad/s)')
ax.set_title('Compass Gait: Phase Portrait of Swing Leg Dynamics'
             f' (slope = {math.degrees(gamma):.1f} deg)')
ax.grid(True, alpha=0.3)
ax.set_xlim(-0.8, 0.8)
ax.set_ylim(-1.5, 1.5)
plt.tight_layout()

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()

print()
print("Phase portrait shows swing leg trajectories from")
print("different initial conditions.")
print("Dots mark starting points. Closed orbits indicate")
print("periodic oscillations (potential limit cycles).")
print(f"Slope angle: {math.degrees(gamma):.1f} degrees")
print(f"Integration: RK4 with dt={dt}, {n_steps} steps")
`}
/>

## From Passive to Active Walking

Passive dynamic walking provides insights for active walker design:

1. **Exploit natural dynamics**: design controllers that work with, not against,
   the robot's natural motion
1. **Minimal actuation**: add small amounts of energy at the right time
   (e.g., ankle push-off) rather than controlling every joint
1. **Limit cycle stability**: design gaits as stable periodic orbits

These principles influenced the development of efficient walking robots
like Cornell's Ranger and Delft's Flame.

### Connections to Other Chapters

- **Hybrid Zero Dynamics (Chapter 9):** HZD uses the same Poincare map
  framework to analyze stability of actively controlled walking gaits.
  The key difference is that HZD adds feedback control to shape the limit cycle,
  whereas passive walkers rely entirely on open-loop dynamics.
- **Reinforcement Learning (Chapter 11):** RL-based locomotion controllers can
  discover energy-efficient gaits that resemble passive walking. The cost of
  transport metric connects passive walking theory to RL reward design.
- **Central Pattern Generators (Chapter 7):** CPGs produce rhythmic motor
  patterns that replicate the limit-cycle structure observed in passive walkers.
  Both approaches share the idea that stable locomotion emerges from periodic
  oscillatory dynamics.

## References

- T. McGeer, "[Passive Dynamic Walking](https://doi.org/10.1177/027836499000900206)," *Int. J. Robotics Research*, 1990.
- A. Goswami et al., "[Limit Cycles in a Passive Compass Gait Biped and Passivity-Mimicking Control Laws](https://doi.org/10.1023/A:1008844026298)," *Autonomous Robots*, 1997.
- S. Collins et al., "[Efficient Bipedal Robots Based on Passive-Dynamic Walkers](https://doi.org/10.1126/science.1107799)," *Science*, 2005.

<InteractiveDemo title="Passive Walker Simulation">
  <p className="text-sm text-gray-500">
    Interactive passive walker on adjustable slope coming soon.
  </p>
</InteractiveDemo>
