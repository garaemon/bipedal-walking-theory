import { MathBlock } from "@/components/math/MathBlock";
import { CodeEditor } from "@/components/code/CodeEditor";
import { InteractiveDemo } from "@/components/visualization/InteractiveDemo";
import { CapturePointDiagram, DCMWalkingDiagram } from "@/components/diagrams/CapturePointDiagram";
import { DCMPhaseDiagram } from "@/components/diagrams/DCMPhaseDiagram";

# Capture Point and DCM

The Capture Point (also called Divergent Component of Motion) provides an
intuitive framework for understanding bipedal balance and designing push
recovery strategies. It answers a fundamental question: *where must the
robot step to avoid falling?*

## Capture Point Definition

The **Capture Point** $\boldsymbol{\xi}$ is the point on the ground where
the robot must place its foot instantaneously to come to a complete stop.

<MathBlock tex="\boldsymbol{\xi} = \mathbf{x} + \frac{1}{\omega}\dot{\mathbf{x}}" />

where $\mathbf{x}$ is the CoM position, $\dot{\mathbf{x}}$ is the CoM velocity,
and $\omega = \sqrt{g/z_c}$ is the LIPM natural frequency.

<CapturePointDiagram />

### Intuition

- If the robot places its foot exactly at $\boldsymbol{\xi}$, the CoM will
  decelerate and stop directly above the foot
- The capture point is always **ahead** of the CoM (in the direction of motion)
- Faster motion pushes $\boldsymbol{\xi}$ further ahead

## Divergent Component of Motion (DCM)

The DCM is mathematically identical to the capture point. The name comes
from decomposing LIPM dynamics into **stable** and **unstable** components.

Start from the LIPM equation $\ddot{x} = \omega^2(x - r)$ (where $r$ is
the CoP). This is a second-order system. To decouple it, rewrite it as
two first-order equations by defining new coordinates:

$$
\xi = x + \frac{\dot{x}}{\omega} \quad \text{(DCM / unstable component)}
$$

$$
\zeta = x - \frac{\dot{x}}{\omega} \quad \text{(stable component)}
$$

Note that $x = \frac{1}{2}(\xi + \zeta)$ and
$\dot{x} = \frac{\omega}{2}(\xi - \zeta)$, so this is an invertible
change of coordinates.

### DCM Dynamics

Differentiating $\xi = x + \dot{x}/\omega$ and substituting
$\ddot{x} = \omega^2(x - r)$:

$$
\dot{\xi} = \dot{x} + \frac{\ddot{x}}{\omega} = \dot{x} + \omega(x - r) = \omega\left(x + \frac{\dot{x}}{\omega} - r\right) = \omega(\xi - r)
$$

Similarly, $\dot{\zeta} = -\omega(\zeta - r)$. The second-order LIPM has
been decomposed into two **independent** first-order systems:
- $\dot{\xi} = +\omega(\xi - r)$: **unstable** (diverges from $r$)
- $\dot{\zeta} = -\omega(\zeta - r)$: **stable** (converges to $r$)

The stable component $\zeta$ takes care of itself, so the controller
only needs to manage the unstable DCM $\xi$. This is why DCM-based
control is so effective.

<DCMPhaseDiagram />

The CoP $r$ acts as the control input for the DCM.

### CoM Dynamics in Terms of DCM

The CoM follows the DCM with first-order stable dynamics:

$$
\dot{x} = -\omega(x - \xi)
$$

This means the CoM always converges toward the DCM â€” a powerful property
for control design.

## Push Recovery

When pushed, the robot's DCM shifts. Recovery strategies:

1. **Ankle strategy**: Adjust CoP within the foot to redirect DCM
2. **Step strategy**: Place foot at the new capture point
3. **Hip strategy**: Use angular momentum to shift DCM

<CodeEditor
  initialCode={`import math
import matplotlib
matplotlib.use('agg')
import matplotlib.pyplot as plt
import numpy as np
import io, base64

# Push recovery using capture point
g = 9.81
z_c = 0.8
omega = math.sqrt(g / z_c)

# Initial state (standing still)
x = 0.0
xdot = 0.0

xi = x + xdot / omega
print("=== Before Push ===")
print(f"CoM: {x:.3f} m, Vel: {xdot:.3f} m/s")
print(f"Capture Point: {xi:.3f} m")
print()

# Apply a push (impulse changes velocity)
push_impulse = 0.3  # m/s velocity change
xdot += push_impulse

xi = x + xdot / omega
print("=== After Push ===")
print(f"CoM: {x:.3f} m, Vel: {xdot:.3f} m/s")
print(f"Capture Point: {xi:.4f} m")
print()

foot_half_length = 0.12
if abs(xi) <= foot_half_length:
    print("Ankle strategy sufficient!")
    print(f"  Move CoP to {xi:.4f} m")
else:
    print("Need stepping strategy!")
    print(f"  Capture point {xi:.4f} m outside foot")
    print(f"  Must step to {xi:.4f} m to recover")
print()

# Simulate recovery by stepping to capture point
r = xi
dt = 0.01
n_sim = 100

time_arr = []
com_arr = []
dcm_arr = []
cp_arr = []

print("=== Recovery Simulation ===")
print("Time(s)  CoM(m)   Vel(m/s)  DCM(m)")
print("-" * 42)

for i in range(n_sim):
    t = i * dt
    xi_dot = omega * (xi - r)
    xi += xi_dot * dt
    xdot = -omega * (x - xi)
    x += xdot * dt

    time_arr.append(t)
    com_arr.append(x)
    dcm_arr.append(xi)
    cp_arr.append(x + xdot / omega)

    if i % 10 == 0:
        print(f"{t:5.2f}    {x:7.4f}  {xdot:7.4f}   {xi:7.4f}")

# Plot recovery trajectory
fig, ax = plt.subplots(figsize=(7, 4))
ax.plot(time_arr, com_arr, 'b-', linewidth=2, label='CoM')
ax.plot(time_arr, dcm_arr, 'r--', linewidth=2, label='DCM')
ax.plot(time_arr, cp_arr, 'g:', linewidth=1.5, label='Capture Pt')
ax.axhline(y=r, color='orange', linestyle='-.',
           linewidth=1, label='Foot (CoP)')
ax.axhline(y=foot_half_length, color='gray',
           linestyle=':', linewidth=0.8, label='Foot boundary')
ax.axhline(y=-foot_half_length, color='gray',
           linestyle=':', linewidth=0.8)
ax.set_xlabel('Time (s)')
ax.set_ylabel('Position (m)')
ax.set_title('Push Recovery: CoM, DCM, and Capture Point')
ax.legend(fontsize=8)
ax.grid(True, alpha=0.3)

buf = io.BytesIO()
plt.savefig(buf, format='png', dpi=100, bbox_inches='tight')
buf.seek(0)
img = base64.b64encode(buf.read()).decode('utf-8')
print(f'data:image/png;base64,{img}')
plt.close()
`}
/>
